// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;
import 'libgstreamer.dart' as imp1;

/// Bindings to libgstapp
class libgstapp {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  libgstapp(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  libgstapp.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  imp1.DartGType gst_base_src_get_type() {
    return _gst_base_src_get_type();
  }

  late final _gst_base_src_get_typePtr =
      _lookup<ffi.NativeFunction<imp1.GType Function()>>(
          'gst_base_src_get_type');
  late final _gst_base_src_get_type =
      _gst_base_src_get_typePtr.asFunction<imp1.DartGType Function()>();

  GstFlowReturn gst_base_src_wait_playing(
    ffi.Pointer<GstBaseSrc> src,
  ) {
    return GstFlowReturn.fromValue(_gst_base_src_wait_playing(
      src,
    ));
  }

  late final _gst_base_src_wait_playingPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<GstBaseSrc>)>>(
          'gst_base_src_wait_playing');
  late final _gst_base_src_wait_playing = _gst_base_src_wait_playingPtr
      .asFunction<int Function(ffi.Pointer<GstBaseSrc>)>();

  void gst_base_src_set_live(
    ffi.Pointer<GstBaseSrc> src,
    int live,
  ) {
    return _gst_base_src_set_live(
      src,
      live,
    );
  }

  late final _gst_base_src_set_livePtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<GstBaseSrc>, ffi.Int)>>(
      'gst_base_src_set_live');
  late final _gst_base_src_set_live = _gst_base_src_set_livePtr
      .asFunction<void Function(ffi.Pointer<GstBaseSrc>, int)>();

  int gst_base_src_is_live(
    ffi.Pointer<GstBaseSrc> src,
  ) {
    return _gst_base_src_is_live(
      src,
    );
  }

  late final _gst_base_src_is_livePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<GstBaseSrc>)>>(
          'gst_base_src_is_live');
  late final _gst_base_src_is_live = _gst_base_src_is_livePtr
      .asFunction<int Function(ffi.Pointer<GstBaseSrc>)>();

  void gst_base_src_set_format(
    ffi.Pointer<GstBaseSrc> src,
    GstFormat format,
  ) {
    return _gst_base_src_set_format(
      src,
      format.value,
    );
  }

  late final _gst_base_src_set_formatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GstBaseSrc>,
              ffi.UnsignedInt)>>('gst_base_src_set_format');
  late final _gst_base_src_set_format = _gst_base_src_set_formatPtr
      .asFunction<void Function(ffi.Pointer<GstBaseSrc>, int)>();

  void gst_base_src_set_dynamic_size(
    ffi.Pointer<GstBaseSrc> src,
    int dynamic1,
  ) {
    return _gst_base_src_set_dynamic_size(
      src,
      dynamic1,
    );
  }

  late final _gst_base_src_set_dynamic_sizePtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<GstBaseSrc>, ffi.Int)>>(
      'gst_base_src_set_dynamic_size');
  late final _gst_base_src_set_dynamic_size = _gst_base_src_set_dynamic_sizePtr
      .asFunction<void Function(ffi.Pointer<GstBaseSrc>, int)>();

  void gst_base_src_set_automatic_eos(
    ffi.Pointer<GstBaseSrc> src,
    int automatic_eos,
  ) {
    return _gst_base_src_set_automatic_eos(
      src,
      automatic_eos,
    );
  }

  late final _gst_base_src_set_automatic_eosPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<GstBaseSrc>, ffi.Int)>>(
      'gst_base_src_set_automatic_eos');
  late final _gst_base_src_set_automatic_eos =
      _gst_base_src_set_automatic_eosPtr
          .asFunction<void Function(ffi.Pointer<GstBaseSrc>, int)>();

  void gst_base_src_set_async(
    ffi.Pointer<GstBaseSrc> src,
    int async1,
  ) {
    return _gst_base_src_set_async(
      src,
      async1,
    );
  }

  late final _gst_base_src_set_asyncPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<GstBaseSrc>, ffi.Int)>>(
      'gst_base_src_set_async');
  late final _gst_base_src_set_async = _gst_base_src_set_asyncPtr
      .asFunction<void Function(ffi.Pointer<GstBaseSrc>, int)>();

  int gst_base_src_is_async(
    ffi.Pointer<GstBaseSrc> src,
  ) {
    return _gst_base_src_is_async(
      src,
    );
  }

  late final _gst_base_src_is_asyncPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<GstBaseSrc>)>>(
          'gst_base_src_is_async');
  late final _gst_base_src_is_async = _gst_base_src_is_asyncPtr
      .asFunction<int Function(ffi.Pointer<GstBaseSrc>)>();

  int gst_base_src_negotiate(
    ffi.Pointer<GstBaseSrc> src,
  ) {
    return _gst_base_src_negotiate(
      src,
    );
  }

  late final _gst_base_src_negotiatePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<GstBaseSrc>)>>(
          'gst_base_src_negotiate');
  late final _gst_base_src_negotiate = _gst_base_src_negotiatePtr
      .asFunction<int Function(ffi.Pointer<GstBaseSrc>)>();

  void gst_base_src_start_complete(
    ffi.Pointer<GstBaseSrc> basesrc,
    GstFlowReturn ret,
  ) {
    return _gst_base_src_start_complete(
      basesrc,
      ret.value,
    );
  }

  late final _gst_base_src_start_completePtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<GstBaseSrc>, ffi.Int)>>(
      'gst_base_src_start_complete');
  late final _gst_base_src_start_complete = _gst_base_src_start_completePtr
      .asFunction<void Function(ffi.Pointer<GstBaseSrc>, int)>();

  GstFlowReturn gst_base_src_start_wait(
    ffi.Pointer<GstBaseSrc> basesrc,
  ) {
    return GstFlowReturn.fromValue(_gst_base_src_start_wait(
      basesrc,
    ));
  }

  late final _gst_base_src_start_waitPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<GstBaseSrc>)>>(
          'gst_base_src_start_wait');
  late final _gst_base_src_start_wait = _gst_base_src_start_waitPtr
      .asFunction<int Function(ffi.Pointer<GstBaseSrc>)>();

  int gst_base_src_query_latency(
    ffi.Pointer<GstBaseSrc> src,
    ffi.Pointer<ffi.Int> live,
    ffi.Pointer<imp1.GstClockTime> min_latency,
    ffi.Pointer<imp1.GstClockTime> max_latency,
  ) {
    return _gst_base_src_query_latency(
      src,
      live,
      min_latency,
      max_latency,
    );
  }

  late final _gst_base_src_query_latencyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<GstBaseSrc>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<imp1.GstClockTime>,
              ffi.Pointer<imp1.GstClockTime>)>>('gst_base_src_query_latency');
  late final _gst_base_src_query_latency =
      _gst_base_src_query_latencyPtr.asFunction<
          int Function(
              ffi.Pointer<GstBaseSrc>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<imp1.GstClockTime>,
              ffi.Pointer<imp1.GstClockTime>)>();

  void gst_base_src_set_blocksize(
    ffi.Pointer<GstBaseSrc> src,
    int blocksize,
  ) {
    return _gst_base_src_set_blocksize(
      src,
      blocksize,
    );
  }

  late final _gst_base_src_set_blocksizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GstBaseSrc>,
              ffi.UnsignedInt)>>('gst_base_src_set_blocksize');
  late final _gst_base_src_set_blocksize = _gst_base_src_set_blocksizePtr
      .asFunction<void Function(ffi.Pointer<GstBaseSrc>, int)>();

  int gst_base_src_get_blocksize(
    ffi.Pointer<GstBaseSrc> src,
  ) {
    return _gst_base_src_get_blocksize(
      src,
    );
  }

  late final _gst_base_src_get_blocksizePtr = _lookup<
          ffi
          .NativeFunction<ffi.UnsignedInt Function(ffi.Pointer<GstBaseSrc>)>>(
      'gst_base_src_get_blocksize');
  late final _gst_base_src_get_blocksize = _gst_base_src_get_blocksizePtr
      .asFunction<int Function(ffi.Pointer<GstBaseSrc>)>();

  void gst_base_src_set_do_timestamp(
    ffi.Pointer<GstBaseSrc> src,
    int timestamp,
  ) {
    return _gst_base_src_set_do_timestamp(
      src,
      timestamp,
    );
  }

  late final _gst_base_src_set_do_timestampPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<GstBaseSrc>, ffi.Int)>>(
      'gst_base_src_set_do_timestamp');
  late final _gst_base_src_set_do_timestamp = _gst_base_src_set_do_timestampPtr
      .asFunction<void Function(ffi.Pointer<GstBaseSrc>, int)>();

  int gst_base_src_get_do_timestamp(
    ffi.Pointer<GstBaseSrc> src,
  ) {
    return _gst_base_src_get_do_timestamp(
      src,
    );
  }

  late final _gst_base_src_get_do_timestampPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<GstBaseSrc>)>>(
          'gst_base_src_get_do_timestamp');
  late final _gst_base_src_get_do_timestamp = _gst_base_src_get_do_timestampPtr
      .asFunction<int Function(ffi.Pointer<GstBaseSrc>)>();

  int gst_base_src_new_seamless_segment(
    ffi.Pointer<GstBaseSrc> src,
    int start,
    int stop,
    int time,
  ) {
    return _gst_base_src_new_seamless_segment(
      src,
      start,
      stop,
      time,
    );
  }

  late final _gst_base_src_new_seamless_segmentPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<GstBaseSrc>, ffi.Int64, ffi.Int64,
              ffi.Int64)>>('gst_base_src_new_seamless_segment');
  late final _gst_base_src_new_seamless_segment =
      _gst_base_src_new_seamless_segmentPtr
          .asFunction<int Function(ffi.Pointer<GstBaseSrc>, int, int, int)>();

  int gst_base_src_new_segment(
    ffi.Pointer<GstBaseSrc> src,
    ffi.Pointer<imp1.GstSegment> segment,
  ) {
    return _gst_base_src_new_segment(
      src,
      segment,
    );
  }

  late final _gst_base_src_new_segmentPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<GstBaseSrc>,
              ffi.Pointer<imp1.GstSegment>)>>('gst_base_src_new_segment');
  late final _gst_base_src_new_segment =
      _gst_base_src_new_segmentPtr.asFunction<
          int Function(
              ffi.Pointer<GstBaseSrc>, ffi.Pointer<imp1.GstSegment>)>();

  int gst_base_src_set_caps(
    ffi.Pointer<GstBaseSrc> src,
    ffi.Pointer<imp1.GstCaps> caps,
  ) {
    return _gst_base_src_set_caps(
      src,
      caps,
    );
  }

  late final _gst_base_src_set_capsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<GstBaseSrc>,
              ffi.Pointer<imp1.GstCaps>)>>('gst_base_src_set_caps');
  late final _gst_base_src_set_caps = _gst_base_src_set_capsPtr.asFunction<
      int Function(ffi.Pointer<GstBaseSrc>, ffi.Pointer<imp1.GstCaps>)>();

  ffi.Pointer<imp1.GstBufferPool> gst_base_src_get_buffer_pool(
    ffi.Pointer<GstBaseSrc> src,
  ) {
    return _gst_base_src_get_buffer_pool(
      src,
    );
  }

  late final _gst_base_src_get_buffer_poolPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<imp1.GstBufferPool> Function(
              ffi.Pointer<GstBaseSrc>)>>('gst_base_src_get_buffer_pool');
  late final _gst_base_src_get_buffer_pool =
      _gst_base_src_get_buffer_poolPtr.asFunction<
          ffi.Pointer<imp1.GstBufferPool> Function(ffi.Pointer<GstBaseSrc>)>();

  void gst_base_src_get_allocator(
    ffi.Pointer<GstBaseSrc> src,
    ffi.Pointer<ffi.Pointer<imp1.GstAllocator>> allocator,
    ffi.Pointer<imp1.GstAllocationParams> params,
  ) {
    return _gst_base_src_get_allocator(
      src,
      allocator,
      params,
    );
  }

  late final _gst_base_src_get_allocatorPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<GstBaseSrc>,
                  ffi.Pointer<ffi.Pointer<imp1.GstAllocator>>,
                  ffi.Pointer<imp1.GstAllocationParams>)>>(
      'gst_base_src_get_allocator');
  late final _gst_base_src_get_allocator =
      _gst_base_src_get_allocatorPtr.asFunction<
          void Function(
              ffi.Pointer<GstBaseSrc>,
              ffi.Pointer<ffi.Pointer<imp1.GstAllocator>>,
              ffi.Pointer<imp1.GstAllocationParams>)>();

  void gst_base_src_submit_buffer_list(
    ffi.Pointer<GstBaseSrc> src,
    ffi.Pointer<imp1.GstBufferList> buffer_list,
  ) {
    return _gst_base_src_submit_buffer_list(
      src,
      buffer_list,
    );
  }

  late final _gst_base_src_submit_buffer_listPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<GstBaseSrc>, ffi.Pointer<imp1.GstBufferList>)>>(
      'gst_base_src_submit_buffer_list');
  late final _gst_base_src_submit_buffer_list =
      _gst_base_src_submit_buffer_listPtr.asFunction<
          void Function(
              ffi.Pointer<GstBaseSrc>, ffi.Pointer<imp1.GstBufferList>)>();

  int gst_base_src_push_segment(
    ffi.Pointer<GstBaseSrc> src,
    ffi.Pointer<imp1.GstSegment> segment,
  ) {
    return _gst_base_src_push_segment(
      src,
      segment,
    );
  }

  late final _gst_base_src_push_segmentPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<GstBaseSrc>,
              ffi.Pointer<imp1.GstSegment>)>>('gst_base_src_push_segment');
  late final _gst_base_src_push_segment =
      _gst_base_src_push_segmentPtr.asFunction<
          int Function(
              ffi.Pointer<GstBaseSrc>, ffi.Pointer<imp1.GstSegment>)>();

  imp1.DartGType gst_push_src_get_type() {
    return _gst_push_src_get_type();
  }

  late final _gst_push_src_get_typePtr =
      _lookup<ffi.NativeFunction<imp1.GType Function()>>(
          'gst_push_src_get_type');
  late final _gst_push_src_get_type =
      _gst_push_src_get_typePtr.asFunction<imp1.DartGType Function()>();

  imp1.DartGType gst_app_stream_type_get_type() {
    return _gst_app_stream_type_get_type();
  }

  late final _gst_app_stream_type_get_typePtr =
      _lookup<ffi.NativeFunction<imp1.GType Function()>>(
          'gst_app_stream_type_get_type');
  late final _gst_app_stream_type_get_type =
      _gst_app_stream_type_get_typePtr.asFunction<imp1.DartGType Function()>();

  imp1.DartGType gst_app_leaky_type_get_type() {
    return _gst_app_leaky_type_get_type();
  }

  late final _gst_app_leaky_type_get_typePtr =
      _lookup<ffi.NativeFunction<imp1.GType Function()>>(
          'gst_app_leaky_type_get_type');
  late final _gst_app_leaky_type_get_type =
      _gst_app_leaky_type_get_typePtr.asFunction<imp1.DartGType Function()>();

  imp1.DartGType gst_app_src_get_type() {
    return _gst_app_src_get_type();
  }

  late final _gst_app_src_get_typePtr =
      _lookup<ffi.NativeFunction<imp1.GType Function()>>(
          'gst_app_src_get_type');
  late final _gst_app_src_get_type =
      _gst_app_src_get_typePtr.asFunction<imp1.DartGType Function()>();

  void gst_app_src_set_caps(
    ffi.Pointer<GstAppSrc> appsrc,
    ffi.Pointer<imp1.GstCaps> caps,
  ) {
    return _gst_app_src_set_caps(
      appsrc,
      caps,
    );
  }

  late final _gst_app_src_set_capsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GstAppSrc>,
              ffi.Pointer<imp1.GstCaps>)>>('gst_app_src_set_caps');
  late final _gst_app_src_set_caps = _gst_app_src_set_capsPtr.asFunction<
      void Function(ffi.Pointer<GstAppSrc>, ffi.Pointer<imp1.GstCaps>)>();

  ffi.Pointer<imp1.GstCaps> gst_app_src_get_caps(
    ffi.Pointer<GstAppSrc> appsrc,
  ) {
    return _gst_app_src_get_caps(
      appsrc,
    );
  }

  late final _gst_app_src_get_capsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<imp1.GstCaps> Function(
              ffi.Pointer<GstAppSrc>)>>('gst_app_src_get_caps');
  late final _gst_app_src_get_caps = _gst_app_src_get_capsPtr
      .asFunction<ffi.Pointer<imp1.GstCaps> Function(ffi.Pointer<GstAppSrc>)>();

  void gst_app_src_set_size(
    ffi.Pointer<GstAppSrc> appsrc,
    int size,
  ) {
    return _gst_app_src_set_size(
      appsrc,
      size,
    );
  }

  late final _gst_app_src_set_sizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GstAppSrc>, ffi.Int64)>>('gst_app_src_set_size');
  late final _gst_app_src_set_size = _gst_app_src_set_sizePtr
      .asFunction<void Function(ffi.Pointer<GstAppSrc>, int)>();

  int gst_app_src_get_size(
    ffi.Pointer<GstAppSrc> appsrc,
  ) {
    return _gst_app_src_get_size(
      appsrc,
    );
  }

  late final _gst_app_src_get_sizePtr =
      _lookup<ffi.NativeFunction<ffi.Int64 Function(ffi.Pointer<GstAppSrc>)>>(
          'gst_app_src_get_size');
  late final _gst_app_src_get_size = _gst_app_src_get_sizePtr
      .asFunction<int Function(ffi.Pointer<GstAppSrc>)>();

  void gst_app_src_set_duration(
    ffi.Pointer<GstAppSrc> appsrc,
    imp1.DartGstClockTime duration,
  ) {
    return _gst_app_src_set_duration(
      appsrc,
      duration,
    );
  }

  late final _gst_app_src_set_durationPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GstAppSrc>,
              imp1.GstClockTime)>>('gst_app_src_set_duration');
  late final _gst_app_src_set_duration =
      _gst_app_src_set_durationPtr.asFunction<
          void Function(ffi.Pointer<GstAppSrc>, imp1.DartGstClockTime)>();

  imp1.DartGstClockTime gst_app_src_get_duration(
    ffi.Pointer<GstAppSrc> appsrc,
  ) {
    return _gst_app_src_get_duration(
      appsrc,
    );
  }

  late final _gst_app_src_get_durationPtr = _lookup<
          ffi
          .NativeFunction<imp1.GstClockTime Function(ffi.Pointer<GstAppSrc>)>>(
      'gst_app_src_get_duration');
  late final _gst_app_src_get_duration = _gst_app_src_get_durationPtr
      .asFunction<imp1.DartGstClockTime Function(ffi.Pointer<GstAppSrc>)>();

  void gst_app_src_set_stream_type(
    ffi.Pointer<GstAppSrc> appsrc,
    GstAppStreamType type,
  ) {
    return _gst_app_src_set_stream_type(
      appsrc,
      type.value,
    );
  }

  late final _gst_app_src_set_stream_typePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GstAppSrc>,
              ffi.UnsignedInt)>>('gst_app_src_set_stream_type');
  late final _gst_app_src_set_stream_type = _gst_app_src_set_stream_typePtr
      .asFunction<void Function(ffi.Pointer<GstAppSrc>, int)>();

  GstAppStreamType gst_app_src_get_stream_type(
    ffi.Pointer<GstAppSrc> appsrc,
  ) {
    return GstAppStreamType.fromValue(_gst_app_src_get_stream_type(
      appsrc,
    ));
  }

  late final _gst_app_src_get_stream_typePtr = _lookup<
          ffi.NativeFunction<ffi.UnsignedInt Function(ffi.Pointer<GstAppSrc>)>>(
      'gst_app_src_get_stream_type');
  late final _gst_app_src_get_stream_type = _gst_app_src_get_stream_typePtr
      .asFunction<int Function(ffi.Pointer<GstAppSrc>)>();

  void gst_app_src_set_max_bytes(
    ffi.Pointer<GstAppSrc> appsrc,
    int max,
  ) {
    return _gst_app_src_set_max_bytes(
      appsrc,
      max,
    );
  }

  late final _gst_app_src_set_max_bytesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GstAppSrc>,
              ffi.Uint64)>>('gst_app_src_set_max_bytes');
  late final _gst_app_src_set_max_bytes = _gst_app_src_set_max_bytesPtr
      .asFunction<void Function(ffi.Pointer<GstAppSrc>, int)>();

  int gst_app_src_get_max_bytes(
    ffi.Pointer<GstAppSrc> appsrc,
  ) {
    return _gst_app_src_get_max_bytes(
      appsrc,
    );
  }

  late final _gst_app_src_get_max_bytesPtr =
      _lookup<ffi.NativeFunction<ffi.Uint64 Function(ffi.Pointer<GstAppSrc>)>>(
          'gst_app_src_get_max_bytes');
  late final _gst_app_src_get_max_bytes = _gst_app_src_get_max_bytesPtr
      .asFunction<int Function(ffi.Pointer<GstAppSrc>)>();

  int gst_app_src_get_current_level_bytes(
    ffi.Pointer<GstAppSrc> appsrc,
  ) {
    return _gst_app_src_get_current_level_bytes(
      appsrc,
    );
  }

  late final _gst_app_src_get_current_level_bytesPtr =
      _lookup<ffi.NativeFunction<ffi.Uint64 Function(ffi.Pointer<GstAppSrc>)>>(
          'gst_app_src_get_current_level_bytes');
  late final _gst_app_src_get_current_level_bytes =
      _gst_app_src_get_current_level_bytesPtr
          .asFunction<int Function(ffi.Pointer<GstAppSrc>)>();

  void gst_app_src_set_max_buffers(
    ffi.Pointer<GstAppSrc> appsrc,
    int max,
  ) {
    return _gst_app_src_set_max_buffers(
      appsrc,
      max,
    );
  }

  late final _gst_app_src_set_max_buffersPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GstAppSrc>,
              ffi.Uint64)>>('gst_app_src_set_max_buffers');
  late final _gst_app_src_set_max_buffers = _gst_app_src_set_max_buffersPtr
      .asFunction<void Function(ffi.Pointer<GstAppSrc>, int)>();

  int gst_app_src_get_max_buffers(
    ffi.Pointer<GstAppSrc> appsrc,
  ) {
    return _gst_app_src_get_max_buffers(
      appsrc,
    );
  }

  late final _gst_app_src_get_max_buffersPtr =
      _lookup<ffi.NativeFunction<ffi.Uint64 Function(ffi.Pointer<GstAppSrc>)>>(
          'gst_app_src_get_max_buffers');
  late final _gst_app_src_get_max_buffers = _gst_app_src_get_max_buffersPtr
      .asFunction<int Function(ffi.Pointer<GstAppSrc>)>();

  int gst_app_src_get_current_level_buffers(
    ffi.Pointer<GstAppSrc> appsrc,
  ) {
    return _gst_app_src_get_current_level_buffers(
      appsrc,
    );
  }

  late final _gst_app_src_get_current_level_buffersPtr =
      _lookup<ffi.NativeFunction<ffi.Uint64 Function(ffi.Pointer<GstAppSrc>)>>(
          'gst_app_src_get_current_level_buffers');
  late final _gst_app_src_get_current_level_buffers =
      _gst_app_src_get_current_level_buffersPtr
          .asFunction<int Function(ffi.Pointer<GstAppSrc>)>();

  void gst_app_src_set_max_time(
    ffi.Pointer<GstAppSrc> appsrc,
    imp1.DartGstClockTime max,
  ) {
    return _gst_app_src_set_max_time(
      appsrc,
      max,
    );
  }

  late final _gst_app_src_set_max_timePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GstAppSrc>,
              imp1.GstClockTime)>>('gst_app_src_set_max_time');
  late final _gst_app_src_set_max_time =
      _gst_app_src_set_max_timePtr.asFunction<
          void Function(ffi.Pointer<GstAppSrc>, imp1.DartGstClockTime)>();

  imp1.DartGstClockTime gst_app_src_get_max_time(
    ffi.Pointer<GstAppSrc> appsrc,
  ) {
    return _gst_app_src_get_max_time(
      appsrc,
    );
  }

  late final _gst_app_src_get_max_timePtr = _lookup<
          ffi
          .NativeFunction<imp1.GstClockTime Function(ffi.Pointer<GstAppSrc>)>>(
      'gst_app_src_get_max_time');
  late final _gst_app_src_get_max_time = _gst_app_src_get_max_timePtr
      .asFunction<imp1.DartGstClockTime Function(ffi.Pointer<GstAppSrc>)>();

  imp1.DartGstClockTime gst_app_src_get_current_level_time(
    ffi.Pointer<GstAppSrc> appsrc,
  ) {
    return _gst_app_src_get_current_level_time(
      appsrc,
    );
  }

  late final _gst_app_src_get_current_level_timePtr = _lookup<
          ffi
          .NativeFunction<imp1.GstClockTime Function(ffi.Pointer<GstAppSrc>)>>(
      'gst_app_src_get_current_level_time');
  late final _gst_app_src_get_current_level_time =
      _gst_app_src_get_current_level_timePtr
          .asFunction<imp1.DartGstClockTime Function(ffi.Pointer<GstAppSrc>)>();

  void gst_app_src_set_leaky_type(
    ffi.Pointer<GstAppSrc> appsrc,
    GstAppLeakyType leaky,
  ) {
    return _gst_app_src_set_leaky_type(
      appsrc,
      leaky.value,
    );
  }

  late final _gst_app_src_set_leaky_typePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GstAppSrc>,
              ffi.UnsignedInt)>>('gst_app_src_set_leaky_type');
  late final _gst_app_src_set_leaky_type = _gst_app_src_set_leaky_typePtr
      .asFunction<void Function(ffi.Pointer<GstAppSrc>, int)>();

  GstAppLeakyType gst_app_src_get_leaky_type(
    ffi.Pointer<GstAppSrc> appsrc,
  ) {
    return GstAppLeakyType.fromValue(_gst_app_src_get_leaky_type(
      appsrc,
    ));
  }

  late final _gst_app_src_get_leaky_typePtr = _lookup<
          ffi.NativeFunction<ffi.UnsignedInt Function(ffi.Pointer<GstAppSrc>)>>(
      'gst_app_src_get_leaky_type');
  late final _gst_app_src_get_leaky_type = _gst_app_src_get_leaky_typePtr
      .asFunction<int Function(ffi.Pointer<GstAppSrc>)>();

  void gst_app_src_set_latency(
    ffi.Pointer<GstAppSrc> appsrc,
    int min,
    int max,
  ) {
    return _gst_app_src_set_latency(
      appsrc,
      min,
      max,
    );
  }

  late final _gst_app_src_set_latencyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GstAppSrc>, ffi.Uint64,
              ffi.Uint64)>>('gst_app_src_set_latency');
  late final _gst_app_src_set_latency = _gst_app_src_set_latencyPtr
      .asFunction<void Function(ffi.Pointer<GstAppSrc>, int, int)>();

  void gst_app_src_get_latency(
    ffi.Pointer<GstAppSrc> appsrc,
    ffi.Pointer<ffi.Uint64> min,
    ffi.Pointer<ffi.Uint64> max,
  ) {
    return _gst_app_src_get_latency(
      appsrc,
      min,
      max,
    );
  }

  late final _gst_app_src_get_latencyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GstAppSrc>, ffi.Pointer<ffi.Uint64>,
              ffi.Pointer<ffi.Uint64>)>>('gst_app_src_get_latency');
  late final _gst_app_src_get_latency = _gst_app_src_get_latencyPtr.asFunction<
      void Function(ffi.Pointer<GstAppSrc>, ffi.Pointer<ffi.Uint64>,
          ffi.Pointer<ffi.Uint64>)>();

  void gst_app_src_set_emit_signals(
    ffi.Pointer<GstAppSrc> appsrc,
    int emit,
  ) {
    return _gst_app_src_set_emit_signals(
      appsrc,
      emit,
    );
  }

  late final _gst_app_src_set_emit_signalsPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<GstAppSrc>, ffi.Int)>>(
      'gst_app_src_set_emit_signals');
  late final _gst_app_src_set_emit_signals = _gst_app_src_set_emit_signalsPtr
      .asFunction<void Function(ffi.Pointer<GstAppSrc>, int)>();

  int gst_app_src_get_emit_signals(
    ffi.Pointer<GstAppSrc> appsrc,
  ) {
    return _gst_app_src_get_emit_signals(
      appsrc,
    );
  }

  late final _gst_app_src_get_emit_signalsPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<GstAppSrc>)>>(
          'gst_app_src_get_emit_signals');
  late final _gst_app_src_get_emit_signals = _gst_app_src_get_emit_signalsPtr
      .asFunction<int Function(ffi.Pointer<GstAppSrc>)>();

  GstFlowReturn gst_app_src_push_buffer(
    ffi.Pointer<GstAppSrc> appsrc,
    ffi.Pointer<imp1.GstBuffer> buffer,
  ) {
    return GstFlowReturn.fromValue(_gst_app_src_push_buffer(
      appsrc,
      buffer,
    ));
  }

  late final _gst_app_src_push_bufferPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<GstAppSrc>,
              ffi.Pointer<imp1.GstBuffer>)>>('gst_app_src_push_buffer');
  late final _gst_app_src_push_buffer = _gst_app_src_push_bufferPtr.asFunction<
      int Function(ffi.Pointer<GstAppSrc>, ffi.Pointer<imp1.GstBuffer>)>();

  GstFlowReturn gst_app_src_push_buffer_list(
    ffi.Pointer<GstAppSrc> appsrc,
    ffi.Pointer<imp1.GstBufferList> buffer_list,
  ) {
    return GstFlowReturn.fromValue(_gst_app_src_push_buffer_list(
      appsrc,
      buffer_list,
    ));
  }

  late final _gst_app_src_push_buffer_listPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<GstAppSrc>, ffi.Pointer<imp1.GstBufferList>)>>(
      'gst_app_src_push_buffer_list');
  late final _gst_app_src_push_buffer_list =
      _gst_app_src_push_buffer_listPtr.asFunction<
          int Function(
              ffi.Pointer<GstAppSrc>, ffi.Pointer<imp1.GstBufferList>)>();

  GstFlowReturn gst_app_src_end_of_stream(
    ffi.Pointer<GstAppSrc> appsrc,
  ) {
    return GstFlowReturn.fromValue(_gst_app_src_end_of_stream(
      appsrc,
    ));
  }

  late final _gst_app_src_end_of_streamPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<GstAppSrc>)>>(
          'gst_app_src_end_of_stream');
  late final _gst_app_src_end_of_stream = _gst_app_src_end_of_streamPtr
      .asFunction<int Function(ffi.Pointer<GstAppSrc>)>();

  GstFlowReturn gst_app_src_push_sample(
    ffi.Pointer<GstAppSrc> appsrc,
    ffi.Pointer<imp1.GstSample> sample,
  ) {
    return GstFlowReturn.fromValue(_gst_app_src_push_sample(
      appsrc,
      sample,
    ));
  }

  late final _gst_app_src_push_samplePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<GstAppSrc>,
              ffi.Pointer<imp1.GstSample>)>>('gst_app_src_push_sample');
  late final _gst_app_src_push_sample = _gst_app_src_push_samplePtr.asFunction<
      int Function(ffi.Pointer<GstAppSrc>, ffi.Pointer<imp1.GstSample>)>();

  void gst_app_src_set_callbacks(
    ffi.Pointer<GstAppSrc> appsrc,
    ffi.Pointer<GstAppSrcCallbacks> callbacks,
    ffi.Pointer user_data,
    imp1.GDestroyNotify notify,
  ) {
    return _gst_app_src_set_callbacks(
      appsrc,
      callbacks,
      user_data,
      notify,
    );
  }

  late final _gst_app_src_set_callbacksPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GstAppSrc>,
              ffi.Pointer<GstAppSrcCallbacks>,
              ffi.Pointer,
              imp1.GDestroyNotify)>>('gst_app_src_set_callbacks');
  late final _gst_app_src_set_callbacks =
      _gst_app_src_set_callbacksPtr.asFunction<
          void Function(ffi.Pointer<GstAppSrc>, ffi.Pointer<GstAppSrcCallbacks>,
              ffi.Pointer, imp1.GDestroyNotify)>();

  imp1.DartGType gst_base_sink_get_type() {
    return _gst_base_sink_get_type();
  }

  late final _gst_base_sink_get_typePtr =
      _lookup<ffi.NativeFunction<imp1.GType Function()>>(
          'gst_base_sink_get_type');
  late final _gst_base_sink_get_type =
      _gst_base_sink_get_typePtr.asFunction<imp1.DartGType Function()>();

  GstFlowReturn gst_base_sink_do_preroll(
    ffi.Pointer<GstBaseSink> sink,
    ffi.Pointer<imp1.GstMiniObject1> obj,
  ) {
    return GstFlowReturn.fromValue(_gst_base_sink_do_preroll(
      sink,
      obj,
    ));
  }

  late final _gst_base_sink_do_prerollPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<GstBaseSink>,
              ffi.Pointer<imp1.GstMiniObject1>)>>('gst_base_sink_do_preroll');
  late final _gst_base_sink_do_preroll =
      _gst_base_sink_do_prerollPtr.asFunction<
          int Function(
              ffi.Pointer<GstBaseSink>, ffi.Pointer<imp1.GstMiniObject1>)>();

  GstFlowReturn gst_base_sink_wait_preroll(
    ffi.Pointer<GstBaseSink> sink,
  ) {
    return GstFlowReturn.fromValue(_gst_base_sink_wait_preroll(
      sink,
    ));
  }

  late final _gst_base_sink_wait_prerollPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<GstBaseSink>)>>(
          'gst_base_sink_wait_preroll');
  late final _gst_base_sink_wait_preroll = _gst_base_sink_wait_prerollPtr
      .asFunction<int Function(ffi.Pointer<GstBaseSink>)>();

  void gst_base_sink_set_sync(
    ffi.Pointer<GstBaseSink> sink,
    int sync1,
  ) {
    return _gst_base_sink_set_sync(
      sink,
      sync1,
    );
  }

  late final _gst_base_sink_set_syncPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GstBaseSink>, ffi.Int)>>('gst_base_sink_set_sync');
  late final _gst_base_sink_set_sync = _gst_base_sink_set_syncPtr
      .asFunction<void Function(ffi.Pointer<GstBaseSink>, int)>();

  int gst_base_sink_get_sync(
    ffi.Pointer<GstBaseSink> sink,
  ) {
    return _gst_base_sink_get_sync(
      sink,
    );
  }

  late final _gst_base_sink_get_syncPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<GstBaseSink>)>>(
          'gst_base_sink_get_sync');
  late final _gst_base_sink_get_sync = _gst_base_sink_get_syncPtr
      .asFunction<int Function(ffi.Pointer<GstBaseSink>)>();

  void gst_base_sink_set_drop_out_of_segment(
    ffi.Pointer<GstBaseSink> sink,
    int drop_out_of_segment,
  ) {
    return _gst_base_sink_set_drop_out_of_segment(
      sink,
      drop_out_of_segment,
    );
  }

  late final _gst_base_sink_set_drop_out_of_segmentPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GstBaseSink>,
              ffi.Int)>>('gst_base_sink_set_drop_out_of_segment');
  late final _gst_base_sink_set_drop_out_of_segment =
      _gst_base_sink_set_drop_out_of_segmentPtr
          .asFunction<void Function(ffi.Pointer<GstBaseSink>, int)>();

  int gst_base_sink_get_drop_out_of_segment(
    ffi.Pointer<GstBaseSink> sink,
  ) {
    return _gst_base_sink_get_drop_out_of_segment(
      sink,
    );
  }

  late final _gst_base_sink_get_drop_out_of_segmentPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<GstBaseSink>)>>(
          'gst_base_sink_get_drop_out_of_segment');
  late final _gst_base_sink_get_drop_out_of_segment =
      _gst_base_sink_get_drop_out_of_segmentPtr
          .asFunction<int Function(ffi.Pointer<GstBaseSink>)>();

  void gst_base_sink_set_max_lateness(
    ffi.Pointer<GstBaseSink> sink,
    int max_lateness,
  ) {
    return _gst_base_sink_set_max_lateness(
      sink,
      max_lateness,
    );
  }

  late final _gst_base_sink_set_max_latenessPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GstBaseSink>,
              ffi.Int64)>>('gst_base_sink_set_max_lateness');
  late final _gst_base_sink_set_max_lateness =
      _gst_base_sink_set_max_latenessPtr
          .asFunction<void Function(ffi.Pointer<GstBaseSink>, int)>();

  int gst_base_sink_get_max_lateness(
    ffi.Pointer<GstBaseSink> sink,
  ) {
    return _gst_base_sink_get_max_lateness(
      sink,
    );
  }

  late final _gst_base_sink_get_max_latenessPtr =
      _lookup<ffi.NativeFunction<ffi.Int64 Function(ffi.Pointer<GstBaseSink>)>>(
          'gst_base_sink_get_max_lateness');
  late final _gst_base_sink_get_max_lateness =
      _gst_base_sink_get_max_latenessPtr
          .asFunction<int Function(ffi.Pointer<GstBaseSink>)>();

  void gst_base_sink_set_qos_enabled(
    ffi.Pointer<GstBaseSink> sink,
    int enabled,
  ) {
    return _gst_base_sink_set_qos_enabled(
      sink,
      enabled,
    );
  }

  late final _gst_base_sink_set_qos_enabledPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GstBaseSink>,
              ffi.Int)>>('gst_base_sink_set_qos_enabled');
  late final _gst_base_sink_set_qos_enabled = _gst_base_sink_set_qos_enabledPtr
      .asFunction<void Function(ffi.Pointer<GstBaseSink>, int)>();

  int gst_base_sink_is_qos_enabled(
    ffi.Pointer<GstBaseSink> sink,
  ) {
    return _gst_base_sink_is_qos_enabled(
      sink,
    );
  }

  late final _gst_base_sink_is_qos_enabledPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<GstBaseSink>)>>(
          'gst_base_sink_is_qos_enabled');
  late final _gst_base_sink_is_qos_enabled = _gst_base_sink_is_qos_enabledPtr
      .asFunction<int Function(ffi.Pointer<GstBaseSink>)>();

  void gst_base_sink_set_async_enabled(
    ffi.Pointer<GstBaseSink> sink,
    int enabled,
  ) {
    return _gst_base_sink_set_async_enabled(
      sink,
      enabled,
    );
  }

  late final _gst_base_sink_set_async_enabledPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GstBaseSink>,
              ffi.Int)>>('gst_base_sink_set_async_enabled');
  late final _gst_base_sink_set_async_enabled =
      _gst_base_sink_set_async_enabledPtr
          .asFunction<void Function(ffi.Pointer<GstBaseSink>, int)>();

  int gst_base_sink_is_async_enabled(
    ffi.Pointer<GstBaseSink> sink,
  ) {
    return _gst_base_sink_is_async_enabled(
      sink,
    );
  }

  late final _gst_base_sink_is_async_enabledPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<GstBaseSink>)>>(
          'gst_base_sink_is_async_enabled');
  late final _gst_base_sink_is_async_enabled =
      _gst_base_sink_is_async_enabledPtr
          .asFunction<int Function(ffi.Pointer<GstBaseSink>)>();

  void gst_base_sink_set_ts_offset(
    ffi.Pointer<GstBaseSink> sink,
    imp1.DartGstClockTimeDiff offset,
  ) {
    return _gst_base_sink_set_ts_offset(
      sink,
      offset,
    );
  }

  late final _gst_base_sink_set_ts_offsetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GstBaseSink>,
              imp1.GstClockTimeDiff)>>('gst_base_sink_set_ts_offset');
  late final _gst_base_sink_set_ts_offset =
      _gst_base_sink_set_ts_offsetPtr.asFunction<
          void Function(ffi.Pointer<GstBaseSink>, imp1.DartGstClockTimeDiff)>();

  imp1.DartGstClockTimeDiff gst_base_sink_get_ts_offset(
    ffi.Pointer<GstBaseSink> sink,
  ) {
    return _gst_base_sink_get_ts_offset(
      sink,
    );
  }

  late final _gst_base_sink_get_ts_offsetPtr = _lookup<
      ffi.NativeFunction<
          imp1.GstClockTimeDiff Function(
              ffi.Pointer<GstBaseSink>)>>('gst_base_sink_get_ts_offset');
  late final _gst_base_sink_get_ts_offset =
      _gst_base_sink_get_ts_offsetPtr.asFunction<
          imp1.DartGstClockTimeDiff Function(ffi.Pointer<GstBaseSink>)>();

  ffi.Pointer<imp1.GstSample> gst_base_sink_get_last_sample(
    ffi.Pointer<GstBaseSink> sink,
  ) {
    return _gst_base_sink_get_last_sample(
      sink,
    );
  }

  late final _gst_base_sink_get_last_samplePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<imp1.GstSample> Function(
              ffi.Pointer<GstBaseSink>)>>('gst_base_sink_get_last_sample');
  late final _gst_base_sink_get_last_sample =
      _gst_base_sink_get_last_samplePtr.asFunction<
          ffi.Pointer<imp1.GstSample> Function(ffi.Pointer<GstBaseSink>)>();

  void gst_base_sink_set_last_sample_enabled(
    ffi.Pointer<GstBaseSink> sink,
    int enabled,
  ) {
    return _gst_base_sink_set_last_sample_enabled(
      sink,
      enabled,
    );
  }

  late final _gst_base_sink_set_last_sample_enabledPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GstBaseSink>,
              ffi.Int)>>('gst_base_sink_set_last_sample_enabled');
  late final _gst_base_sink_set_last_sample_enabled =
      _gst_base_sink_set_last_sample_enabledPtr
          .asFunction<void Function(ffi.Pointer<GstBaseSink>, int)>();

  int gst_base_sink_is_last_sample_enabled(
    ffi.Pointer<GstBaseSink> sink,
  ) {
    return _gst_base_sink_is_last_sample_enabled(
      sink,
    );
  }

  late final _gst_base_sink_is_last_sample_enabledPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<GstBaseSink>)>>(
          'gst_base_sink_is_last_sample_enabled');
  late final _gst_base_sink_is_last_sample_enabled =
      _gst_base_sink_is_last_sample_enabledPtr
          .asFunction<int Function(ffi.Pointer<GstBaseSink>)>();

  int gst_base_sink_query_latency(
    ffi.Pointer<GstBaseSink> sink,
    ffi.Pointer<ffi.Int> live,
    ffi.Pointer<ffi.Int> upstream_live,
    ffi.Pointer<imp1.GstClockTime> min_latency,
    ffi.Pointer<imp1.GstClockTime> max_latency,
  ) {
    return _gst_base_sink_query_latency(
      sink,
      live,
      upstream_live,
      min_latency,
      max_latency,
    );
  }

  late final _gst_base_sink_query_latencyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<GstBaseSink>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<imp1.GstClockTime>,
              ffi.Pointer<imp1.GstClockTime>)>>('gst_base_sink_query_latency');
  late final _gst_base_sink_query_latency =
      _gst_base_sink_query_latencyPtr.asFunction<
          int Function(
              ffi.Pointer<GstBaseSink>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<imp1.GstClockTime>,
              ffi.Pointer<imp1.GstClockTime>)>();

  imp1.DartGstClockTime gst_base_sink_get_latency(
    ffi.Pointer<GstBaseSink> sink,
  ) {
    return _gst_base_sink_get_latency(
      sink,
    );
  }

  late final _gst_base_sink_get_latencyPtr = _lookup<
      ffi.NativeFunction<
          imp1.GstClockTime Function(
              ffi.Pointer<GstBaseSink>)>>('gst_base_sink_get_latency');
  late final _gst_base_sink_get_latency = _gst_base_sink_get_latencyPtr
      .asFunction<imp1.DartGstClockTime Function(ffi.Pointer<GstBaseSink>)>();

  void gst_base_sink_set_render_delay(
    ffi.Pointer<GstBaseSink> sink,
    imp1.DartGstClockTime delay,
  ) {
    return _gst_base_sink_set_render_delay(
      sink,
      delay,
    );
  }

  late final _gst_base_sink_set_render_delayPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GstBaseSink>,
              imp1.GstClockTime)>>('gst_base_sink_set_render_delay');
  late final _gst_base_sink_set_render_delay =
      _gst_base_sink_set_render_delayPtr.asFunction<
          void Function(ffi.Pointer<GstBaseSink>, imp1.DartGstClockTime)>();

  imp1.DartGstClockTime gst_base_sink_get_render_delay(
    ffi.Pointer<GstBaseSink> sink,
  ) {
    return _gst_base_sink_get_render_delay(
      sink,
    );
  }

  late final _gst_base_sink_get_render_delayPtr = _lookup<
      ffi.NativeFunction<
          imp1.GstClockTime Function(
              ffi.Pointer<GstBaseSink>)>>('gst_base_sink_get_render_delay');
  late final _gst_base_sink_get_render_delay =
      _gst_base_sink_get_render_delayPtr.asFunction<
          imp1.DartGstClockTime Function(ffi.Pointer<GstBaseSink>)>();

  void gst_base_sink_set_blocksize(
    ffi.Pointer<GstBaseSink> sink,
    int blocksize,
  ) {
    return _gst_base_sink_set_blocksize(
      sink,
      blocksize,
    );
  }

  late final _gst_base_sink_set_blocksizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GstBaseSink>,
              ffi.UnsignedInt)>>('gst_base_sink_set_blocksize');
  late final _gst_base_sink_set_blocksize = _gst_base_sink_set_blocksizePtr
      .asFunction<void Function(ffi.Pointer<GstBaseSink>, int)>();

  int gst_base_sink_get_blocksize(
    ffi.Pointer<GstBaseSink> sink,
  ) {
    return _gst_base_sink_get_blocksize(
      sink,
    );
  }

  late final _gst_base_sink_get_blocksizePtr = _lookup<
          ffi
          .NativeFunction<ffi.UnsignedInt Function(ffi.Pointer<GstBaseSink>)>>(
      'gst_base_sink_get_blocksize');
  late final _gst_base_sink_get_blocksize = _gst_base_sink_get_blocksizePtr
      .asFunction<int Function(ffi.Pointer<GstBaseSink>)>();

  void gst_base_sink_set_throttle_time(
    ffi.Pointer<GstBaseSink> sink,
    int throttle,
  ) {
    return _gst_base_sink_set_throttle_time(
      sink,
      throttle,
    );
  }

  late final _gst_base_sink_set_throttle_timePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GstBaseSink>,
              ffi.Uint64)>>('gst_base_sink_set_throttle_time');
  late final _gst_base_sink_set_throttle_time =
      _gst_base_sink_set_throttle_timePtr
          .asFunction<void Function(ffi.Pointer<GstBaseSink>, int)>();

  int gst_base_sink_get_throttle_time(
    ffi.Pointer<GstBaseSink> sink,
  ) {
    return _gst_base_sink_get_throttle_time(
      sink,
    );
  }

  late final _gst_base_sink_get_throttle_timePtr = _lookup<
          ffi.NativeFunction<ffi.Uint64 Function(ffi.Pointer<GstBaseSink>)>>(
      'gst_base_sink_get_throttle_time');
  late final _gst_base_sink_get_throttle_time =
      _gst_base_sink_get_throttle_timePtr
          .asFunction<int Function(ffi.Pointer<GstBaseSink>)>();

  void gst_base_sink_set_max_bitrate(
    ffi.Pointer<GstBaseSink> sink,
    int max_bitrate,
  ) {
    return _gst_base_sink_set_max_bitrate(
      sink,
      max_bitrate,
    );
  }

  late final _gst_base_sink_set_max_bitratePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GstBaseSink>,
              ffi.Uint64)>>('gst_base_sink_set_max_bitrate');
  late final _gst_base_sink_set_max_bitrate = _gst_base_sink_set_max_bitratePtr
      .asFunction<void Function(ffi.Pointer<GstBaseSink>, int)>();

  int gst_base_sink_get_max_bitrate(
    ffi.Pointer<GstBaseSink> sink,
  ) {
    return _gst_base_sink_get_max_bitrate(
      sink,
    );
  }

  late final _gst_base_sink_get_max_bitratePtr = _lookup<
          ffi.NativeFunction<ffi.Uint64 Function(ffi.Pointer<GstBaseSink>)>>(
      'gst_base_sink_get_max_bitrate');
  late final _gst_base_sink_get_max_bitrate = _gst_base_sink_get_max_bitratePtr
      .asFunction<int Function(ffi.Pointer<GstBaseSink>)>();

  void gst_base_sink_set_processing_deadline(
    ffi.Pointer<GstBaseSink> sink,
    imp1.DartGstClockTime processing_deadline,
  ) {
    return _gst_base_sink_set_processing_deadline(
      sink,
      processing_deadline,
    );
  }

  late final _gst_base_sink_set_processing_deadlinePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GstBaseSink>,
              imp1.GstClockTime)>>('gst_base_sink_set_processing_deadline');
  late final _gst_base_sink_set_processing_deadline =
      _gst_base_sink_set_processing_deadlinePtr.asFunction<
          void Function(ffi.Pointer<GstBaseSink>, imp1.DartGstClockTime)>();

  imp1.DartGstClockTime gst_base_sink_get_processing_deadline(
    ffi.Pointer<GstBaseSink> sink,
  ) {
    return _gst_base_sink_get_processing_deadline(
      sink,
    );
  }

  late final _gst_base_sink_get_processing_deadlinePtr = _lookup<
          ffi.NativeFunction<
              imp1.GstClockTime Function(ffi.Pointer<GstBaseSink>)>>(
      'gst_base_sink_get_processing_deadline');
  late final _gst_base_sink_get_processing_deadline =
      _gst_base_sink_get_processing_deadlinePtr.asFunction<
          imp1.DartGstClockTime Function(ffi.Pointer<GstBaseSink>)>();

  GstClockReturn gst_base_sink_wait_clock(
    ffi.Pointer<GstBaseSink> sink,
    imp1.DartGstClockTime time,
    ffi.Pointer<imp1.GstClockTimeDiff> jitter,
  ) {
    return GstClockReturn.fromValue(_gst_base_sink_wait_clock(
      sink,
      time,
      jitter,
    ));
  }

  late final _gst_base_sink_wait_clockPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(ffi.Pointer<GstBaseSink>, imp1.GstClockTime,
              ffi.Pointer<imp1.GstClockTimeDiff>)>>('gst_base_sink_wait_clock');
  late final _gst_base_sink_wait_clock =
      _gst_base_sink_wait_clockPtr.asFunction<
          int Function(ffi.Pointer<GstBaseSink>, imp1.DartGstClockTime,
              ffi.Pointer<imp1.GstClockTimeDiff>)>();

  GstFlowReturn gst_base_sink_wait(
    ffi.Pointer<GstBaseSink> sink,
    imp1.DartGstClockTime time,
    ffi.Pointer<imp1.GstClockTimeDiff> jitter,
  ) {
    return GstFlowReturn.fromValue(_gst_base_sink_wait(
      sink,
      time,
      jitter,
    ));
  }

  late final _gst_base_sink_waitPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<GstBaseSink>, imp1.GstClockTime,
              ffi.Pointer<imp1.GstClockTimeDiff>)>>('gst_base_sink_wait');
  late final _gst_base_sink_wait = _gst_base_sink_waitPtr.asFunction<
      int Function(ffi.Pointer<GstBaseSink>, imp1.DartGstClockTime,
          ffi.Pointer<imp1.GstClockTimeDiff>)>();

  ffi.Pointer<imp1.GstStructure> gst_base_sink_get_stats(
    ffi.Pointer<GstBaseSink> sink,
  ) {
    return _gst_base_sink_get_stats(
      sink,
    );
  }

  late final _gst_base_sink_get_statsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<imp1.GstStructure> Function(
              ffi.Pointer<GstBaseSink>)>>('gst_base_sink_get_stats');
  late final _gst_base_sink_get_stats = _gst_base_sink_get_statsPtr.asFunction<
      ffi.Pointer<imp1.GstStructure> Function(ffi.Pointer<GstBaseSink>)>();

  imp1.DartGType gst_app_sink_get_type() {
    return _gst_app_sink_get_type();
  }

  late final _gst_app_sink_get_typePtr =
      _lookup<ffi.NativeFunction<imp1.GType Function()>>(
          'gst_app_sink_get_type');
  late final _gst_app_sink_get_type =
      _gst_app_sink_get_typePtr.asFunction<imp1.DartGType Function()>();

  void gst_app_sink_set_caps(
    ffi.Pointer<GstAppSink> appsink,
    ffi.Pointer<imp1.GstCaps> caps,
  ) {
    return _gst_app_sink_set_caps(
      appsink,
      caps,
    );
  }

  late final _gst_app_sink_set_capsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GstAppSink>,
              ffi.Pointer<imp1.GstCaps>)>>('gst_app_sink_set_caps');
  late final _gst_app_sink_set_caps = _gst_app_sink_set_capsPtr.asFunction<
      void Function(ffi.Pointer<GstAppSink>, ffi.Pointer<imp1.GstCaps>)>();

  ffi.Pointer<imp1.GstCaps> gst_app_sink_get_caps(
    ffi.Pointer<GstAppSink> appsink,
  ) {
    return _gst_app_sink_get_caps(
      appsink,
    );
  }

  late final _gst_app_sink_get_capsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<imp1.GstCaps> Function(
              ffi.Pointer<GstAppSink>)>>('gst_app_sink_get_caps');
  late final _gst_app_sink_get_caps = _gst_app_sink_get_capsPtr.asFunction<
      ffi.Pointer<imp1.GstCaps> Function(ffi.Pointer<GstAppSink>)>();

  int gst_app_sink_is_eos(
    ffi.Pointer<GstAppSink> appsink,
  ) {
    return _gst_app_sink_is_eos(
      appsink,
    );
  }

  late final _gst_app_sink_is_eosPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<GstAppSink>)>>(
          'gst_app_sink_is_eos');
  late final _gst_app_sink_is_eos = _gst_app_sink_is_eosPtr
      .asFunction<int Function(ffi.Pointer<GstAppSink>)>();

  void gst_app_sink_set_emit_signals(
    ffi.Pointer<GstAppSink> appsink,
    int emit,
  ) {
    return _gst_app_sink_set_emit_signals(
      appsink,
      emit,
    );
  }

  late final _gst_app_sink_set_emit_signalsPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<GstAppSink>, ffi.Int)>>(
      'gst_app_sink_set_emit_signals');
  late final _gst_app_sink_set_emit_signals = _gst_app_sink_set_emit_signalsPtr
      .asFunction<void Function(ffi.Pointer<GstAppSink>, int)>();

  int gst_app_sink_get_emit_signals(
    ffi.Pointer<GstAppSink> appsink,
  ) {
    return _gst_app_sink_get_emit_signals(
      appsink,
    );
  }

  late final _gst_app_sink_get_emit_signalsPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<GstAppSink>)>>(
          'gst_app_sink_get_emit_signals');
  late final _gst_app_sink_get_emit_signals = _gst_app_sink_get_emit_signalsPtr
      .asFunction<int Function(ffi.Pointer<GstAppSink>)>();

  void gst_app_sink_set_max_buffers(
    ffi.Pointer<GstAppSink> appsink,
    int max,
  ) {
    return _gst_app_sink_set_max_buffers(
      appsink,
      max,
    );
  }

  late final _gst_app_sink_set_max_buffersPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GstAppSink>,
              ffi.UnsignedInt)>>('gst_app_sink_set_max_buffers');
  late final _gst_app_sink_set_max_buffers = _gst_app_sink_set_max_buffersPtr
      .asFunction<void Function(ffi.Pointer<GstAppSink>, int)>();

  int gst_app_sink_get_max_buffers(
    ffi.Pointer<GstAppSink> appsink,
  ) {
    return _gst_app_sink_get_max_buffers(
      appsink,
    );
  }

  late final _gst_app_sink_get_max_buffersPtr = _lookup<
          ffi
          .NativeFunction<ffi.UnsignedInt Function(ffi.Pointer<GstAppSink>)>>(
      'gst_app_sink_get_max_buffers');
  late final _gst_app_sink_get_max_buffers = _gst_app_sink_get_max_buffersPtr
      .asFunction<int Function(ffi.Pointer<GstAppSink>)>();

  void gst_app_sink_set_max_time(
    ffi.Pointer<GstAppSink> appsink,
    imp1.DartGstClockTime max,
  ) {
    return _gst_app_sink_set_max_time(
      appsink,
      max,
    );
  }

  late final _gst_app_sink_set_max_timePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GstAppSink>,
              imp1.GstClockTime)>>('gst_app_sink_set_max_time');
  late final _gst_app_sink_set_max_time =
      _gst_app_sink_set_max_timePtr.asFunction<
          void Function(ffi.Pointer<GstAppSink>, imp1.DartGstClockTime)>();

  imp1.DartGstClockTime gst_app_sink_get_max_time(
    ffi.Pointer<GstAppSink> appsink,
  ) {
    return _gst_app_sink_get_max_time(
      appsink,
    );
  }

  late final _gst_app_sink_get_max_timePtr = _lookup<
          ffi
          .NativeFunction<imp1.GstClockTime Function(ffi.Pointer<GstAppSink>)>>(
      'gst_app_sink_get_max_time');
  late final _gst_app_sink_get_max_time = _gst_app_sink_get_max_timePtr
      .asFunction<imp1.DartGstClockTime Function(ffi.Pointer<GstAppSink>)>();

  void gst_app_sink_set_max_bytes(
    ffi.Pointer<GstAppSink> appsink,
    int max,
  ) {
    return _gst_app_sink_set_max_bytes(
      appsink,
      max,
    );
  }

  late final _gst_app_sink_set_max_bytesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GstAppSink>,
              ffi.Uint64)>>('gst_app_sink_set_max_bytes');
  late final _gst_app_sink_set_max_bytes = _gst_app_sink_set_max_bytesPtr
      .asFunction<void Function(ffi.Pointer<GstAppSink>, int)>();

  int gst_app_sink_get_max_bytes(
    ffi.Pointer<GstAppSink> appsink,
  ) {
    return _gst_app_sink_get_max_bytes(
      appsink,
    );
  }

  late final _gst_app_sink_get_max_bytesPtr =
      _lookup<ffi.NativeFunction<ffi.Uint64 Function(ffi.Pointer<GstAppSink>)>>(
          'gst_app_sink_get_max_bytes');
  late final _gst_app_sink_get_max_bytes = _gst_app_sink_get_max_bytesPtr
      .asFunction<int Function(ffi.Pointer<GstAppSink>)>();

  void gst_app_sink_set_drop(
    ffi.Pointer<GstAppSink> appsink,
    int drop,
  ) {
    return _gst_app_sink_set_drop(
      appsink,
      drop,
    );
  }

  late final _gst_app_sink_set_dropPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<GstAppSink>, ffi.Int)>>(
      'gst_app_sink_set_drop');
  late final _gst_app_sink_set_drop = _gst_app_sink_set_dropPtr
      .asFunction<void Function(ffi.Pointer<GstAppSink>, int)>();

  int gst_app_sink_get_drop(
    ffi.Pointer<GstAppSink> appsink,
  ) {
    return _gst_app_sink_get_drop(
      appsink,
    );
  }

  late final _gst_app_sink_get_dropPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<GstAppSink>)>>(
          'gst_app_sink_get_drop');
  late final _gst_app_sink_get_drop = _gst_app_sink_get_dropPtr
      .asFunction<int Function(ffi.Pointer<GstAppSink>)>();

  void gst_app_sink_set_buffer_list_support(
    ffi.Pointer<GstAppSink> appsink,
    int enable_lists,
  ) {
    return _gst_app_sink_set_buffer_list_support(
      appsink,
      enable_lists,
    );
  }

  late final _gst_app_sink_set_buffer_list_supportPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<GstAppSink>, ffi.Int)>>(
      'gst_app_sink_set_buffer_list_support');
  late final _gst_app_sink_set_buffer_list_support =
      _gst_app_sink_set_buffer_list_supportPtr
          .asFunction<void Function(ffi.Pointer<GstAppSink>, int)>();

  int gst_app_sink_get_buffer_list_support(
    ffi.Pointer<GstAppSink> appsink,
  ) {
    return _gst_app_sink_get_buffer_list_support(
      appsink,
    );
  }

  late final _gst_app_sink_get_buffer_list_supportPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<GstAppSink>)>>(
          'gst_app_sink_get_buffer_list_support');
  late final _gst_app_sink_get_buffer_list_support =
      _gst_app_sink_get_buffer_list_supportPtr
          .asFunction<int Function(ffi.Pointer<GstAppSink>)>();

  void gst_app_sink_set_wait_on_eos(
    ffi.Pointer<GstAppSink> appsink,
    int wait,
  ) {
    return _gst_app_sink_set_wait_on_eos(
      appsink,
      wait,
    );
  }

  late final _gst_app_sink_set_wait_on_eosPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<GstAppSink>, ffi.Int)>>(
      'gst_app_sink_set_wait_on_eos');
  late final _gst_app_sink_set_wait_on_eos = _gst_app_sink_set_wait_on_eosPtr
      .asFunction<void Function(ffi.Pointer<GstAppSink>, int)>();

  int gst_app_sink_get_wait_on_eos(
    ffi.Pointer<GstAppSink> appsink,
  ) {
    return _gst_app_sink_get_wait_on_eos(
      appsink,
    );
  }

  late final _gst_app_sink_get_wait_on_eosPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<GstAppSink>)>>(
          'gst_app_sink_get_wait_on_eos');
  late final _gst_app_sink_get_wait_on_eos = _gst_app_sink_get_wait_on_eosPtr
      .asFunction<int Function(ffi.Pointer<GstAppSink>)>();

  ffi.Pointer<imp1.GstSample> gst_app_sink_pull_preroll(
    ffi.Pointer<GstAppSink> appsink,
  ) {
    return _gst_app_sink_pull_preroll(
      appsink,
    );
  }

  late final _gst_app_sink_pull_prerollPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<imp1.GstSample> Function(
              ffi.Pointer<GstAppSink>)>>('gst_app_sink_pull_preroll');
  late final _gst_app_sink_pull_preroll =
      _gst_app_sink_pull_prerollPtr.asFunction<
          ffi.Pointer<imp1.GstSample> Function(ffi.Pointer<GstAppSink>)>();

  ffi.Pointer<imp1.GstSample> gst_app_sink_pull_sample(
    ffi.Pointer<GstAppSink> appsink,
  ) {
    return _gst_app_sink_pull_sample(
      appsink,
    );
  }

  late final _gst_app_sink_pull_samplePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<imp1.GstSample> Function(
              ffi.Pointer<GstAppSink>)>>('gst_app_sink_pull_sample');
  late final _gst_app_sink_pull_sample =
      _gst_app_sink_pull_samplePtr.asFunction<
          ffi.Pointer<imp1.GstSample> Function(ffi.Pointer<GstAppSink>)>();

  ffi.Pointer<imp1.GstMiniObject1> gst_app_sink_pull_object(
    ffi.Pointer<GstAppSink> appsink,
  ) {
    return _gst_app_sink_pull_object(
      appsink,
    );
  }

  late final _gst_app_sink_pull_objectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<imp1.GstMiniObject1> Function(
              ffi.Pointer<GstAppSink>)>>('gst_app_sink_pull_object');
  late final _gst_app_sink_pull_object =
      _gst_app_sink_pull_objectPtr.asFunction<
          ffi.Pointer<imp1.GstMiniObject1> Function(ffi.Pointer<GstAppSink>)>();

  ffi.Pointer<imp1.GstSample> gst_app_sink_try_pull_preroll(
    ffi.Pointer<GstAppSink> appsink,
    imp1.DartGstClockTime timeout,
  ) {
    return _gst_app_sink_try_pull_preroll(
      appsink,
      timeout,
    );
  }

  late final _gst_app_sink_try_pull_prerollPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<imp1.GstSample> Function(ffi.Pointer<GstAppSink>,
              imp1.GstClockTime)>>('gst_app_sink_try_pull_preroll');
  late final _gst_app_sink_try_pull_preroll =
      _gst_app_sink_try_pull_prerollPtr.asFunction<
          ffi.Pointer<imp1.GstSample> Function(
              ffi.Pointer<GstAppSink>, imp1.DartGstClockTime)>();

  ffi.Pointer<imp1.GstSample> gst_app_sink_try_pull_sample(
    ffi.Pointer<GstAppSink> appsink,
    imp1.DartGstClockTime timeout,
  ) {
    return _gst_app_sink_try_pull_sample(
      appsink,
      timeout,
    );
  }

  late final _gst_app_sink_try_pull_samplePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<imp1.GstSample> Function(ffi.Pointer<GstAppSink>,
              imp1.GstClockTime)>>('gst_app_sink_try_pull_sample');
  late final _gst_app_sink_try_pull_sample =
      _gst_app_sink_try_pull_samplePtr.asFunction<
          ffi.Pointer<imp1.GstSample> Function(
              ffi.Pointer<GstAppSink>, imp1.DartGstClockTime)>();

  ffi.Pointer<imp1.GstMiniObject1> gst_app_sink_try_pull_object(
    ffi.Pointer<GstAppSink> appsink,
    imp1.DartGstClockTime timeout,
  ) {
    return _gst_app_sink_try_pull_object(
      appsink,
      timeout,
    );
  }

  late final _gst_app_sink_try_pull_objectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<imp1.GstMiniObject1> Function(ffi.Pointer<GstAppSink>,
              imp1.GstClockTime)>>('gst_app_sink_try_pull_object');
  late final _gst_app_sink_try_pull_object =
      _gst_app_sink_try_pull_objectPtr.asFunction<
          ffi.Pointer<imp1.GstMiniObject1> Function(
              ffi.Pointer<GstAppSink>, imp1.DartGstClockTime)>();

  void gst_app_sink_set_callbacks(
    ffi.Pointer<GstAppSink> appsink,
    ffi.Pointer<GstAppSinkCallbacks> callbacks,
    ffi.Pointer user_data,
    imp1.GDestroyNotify notify,
  ) {
    return _gst_app_sink_set_callbacks(
      appsink,
      callbacks,
      user_data,
      notify,
    );
  }

  late final _gst_app_sink_set_callbacksPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GstAppSink>,
              ffi.Pointer<GstAppSinkCallbacks>,
              ffi.Pointer,
              imp1.GDestroyNotify)>>('gst_app_sink_set_callbacks');
  late final _gst_app_sink_set_callbacks =
      _gst_app_sink_set_callbacksPtr.asFunction<
          void Function(
              ffi.Pointer<GstAppSink>,
              ffi.Pointer<GstAppSinkCallbacks>,
              ffi.Pointer,
              imp1.GDestroyNotify)>();
}

typedef max_align_t = imp1.max_align_t;
typedef fsid_t_ = imp1.fsid_t_;
typedef div_t = imp1.div_t;
typedef ldiv_t = imp1.ldiv_t;
typedef lldiv_t = imp1.lldiv_t;
typedef sigset_t_ = imp1.sigset_t_;
typedef fd_set = imp1.fd_set;
typedef atomic_wide_counter_ = imp1.atomic_wide_counter_;
typedef once_flag_ = imp1.once_flag_;
typedef pthread_mutexattr_t = imp1.pthread_mutexattr_t;
typedef pthread_condattr_t = imp1.pthread_condattr_t;
typedef pthread_attr_t = imp1.pthread_attr_t;
typedef pthread_mutex_t = imp1.pthread_mutex_t;
typedef pthread_cond_t = imp1.pthread_cond_t;
typedef pthread_rwlock_t = imp1.pthread_rwlock_t;
typedef pthread_rwlockattr_t = imp1.pthread_rwlockattr_t;
typedef pthread_barrier_t = imp1.pthread_barrier_t;
typedef pthread_barrierattr_t = imp1.pthread_barrierattr_t;
typedef siginfo_t = imp1.siginfo_t;
typedef stack_t = imp1.stack_t;
typedef mcontext_t = imp1.mcontext_t;
typedef ucontext_t = imp1.ucontext_t;
typedef GTestCase = imp1.GTestCase;
typedef GTestSuite = imp1.GTestSuite;
typedef GTestConfig = imp1.GTestConfig;
typedef GTestLogMsg = imp1.GTestLogMsg;
typedef GTestLogBuffer = imp1.GTestLogBuffer;
typedef cpu_set_t = imp1.cpu_set_t;
typedef pthread_unwind_buf_t_ = imp1.pthread_unwind_buf_t_;
typedef GStaticMutex = imp1.GStaticMutex;
typedef GWeakRef = imp1.GWeakRef;

/// GstClockReturn:
/// @GST_CLOCK_OK: The operation succeeded.
/// @GST_CLOCK_EARLY: The operation was scheduled too late.
/// @GST_CLOCK_UNSCHEDULED: The clockID was unscheduled
/// @GST_CLOCK_BUSY: The ClockID is busy
/// @GST_CLOCK_BADTIME: A bad time was provided to a function.
/// @GST_CLOCK_ERROR: An error occurred
/// @GST_CLOCK_UNSUPPORTED: Operation is not supported
/// @GST_CLOCK_DONE: The ClockID is done waiting
///
/// The return value of a clock operation.
enum GstClockReturn {
  GST_CLOCK_OK(0),
  GST_CLOCK_EARLY(1),
  GST_CLOCK_UNSCHEDULED(2),
  GST_CLOCK_BUSY(3),
  GST_CLOCK_BADTIME(4),
  GST_CLOCK_ERROR(5),
  GST_CLOCK_UNSUPPORTED(6),
  GST_CLOCK_DONE(7);

  final int value;
  const GstClockReturn(this.value);

  static GstClockReturn fromValue(int value) => switch (value) {
        0 => GST_CLOCK_OK,
        1 => GST_CLOCK_EARLY,
        2 => GST_CLOCK_UNSCHEDULED,
        3 => GST_CLOCK_BUSY,
        4 => GST_CLOCK_BADTIME,
        5 => GST_CLOCK_ERROR,
        6 => GST_CLOCK_UNSUPPORTED,
        7 => GST_CLOCK_DONE,
        _ => throw ArgumentError("Unknown value for GstClockReturn: $value"),
      };
}

/// GstPadMode:
/// @GST_PAD_MODE_NONE: Pad will not handle dataflow
/// @GST_PAD_MODE_PUSH: Pad handles dataflow in downstream push mode
/// @GST_PAD_MODE_PULL: Pad handles dataflow in upstream pull mode
///
/// The status of a GstPad. After activating a pad, which usually happens when the
/// parent element goes from READY to PAUSED, the GstPadMode defines if the
/// pad operates in push or pull mode.
enum GstPadMode {
  GST_PAD_MODE_NONE(0),
  GST_PAD_MODE_PUSH(1),
  GST_PAD_MODE_PULL(2);

  final int value;
  const GstPadMode(this.value);

  static GstPadMode fromValue(int value) => switch (value) {
        0 => GST_PAD_MODE_NONE,
        1 => GST_PAD_MODE_PUSH,
        2 => GST_PAD_MODE_PULL,
        _ => throw ArgumentError("Unknown value for GstPadMode: $value"),
      };
}

/// GstMapInfo:
/// @memory: a pointer to the mapped memory
/// @flags: flags used when mapping the memory
/// @data: (array length=size): a pointer to the mapped data
/// @size: the valid size in @data
/// @maxsize: the maximum bytes in @data
/// @user_data: extra private user_data that the implementation of the memory
/// can use to store extra info.
///
/// A structure containing the result of a map operation such as
/// gst_memory_map(). It contains the data and size.
///
/// #GstMapInfo cannot be used with g_auto() because it is ambiguous whether it
/// needs to be unmapped using gst_buffer_unmap() or gst_memory_unmap(). Instead,
/// #GstBufferMapInfo and #GstMemoryMapInfo can be used in that case.
typedef GstMapInfo = imp1.GstMapInfo;

/// GstCustomMeta:
/// @meta: parent #GstMeta
/// @structure: a #GstStructure containing custom metadata. (Since: 1.24)
///
/// Extra custom metadata. The @structure field is the same as returned by
/// gst_custom_meta_get_structure().
///
/// Since 1.24 it can be serialized using gst_meta_serialize() and
/// gst_meta_deserialize(), but only if the #GstStructure does not contain any
/// fields that cannot be serialized, see %GST_SERIALIZE_FLAG_STRICT.
///
/// Since: 1.20
typedef GstCustomMeta = imp1.GstCustomMeta;

/// GstMetaTransformCopy:
/// @region: %TRUE if only region is copied
/// @offset: the offset to copy, 0 if @region is %FALSE, otherwise > 0
/// @size: the size to copy, -1 or the buffer size when @region is %FALSE
///
/// Extra data passed to a "gst-copy" transform #GstMetaTransformFunction.
typedef GstMetaTransformCopy = imp1.GstMetaTransformCopy;

/// GstFormat:
/// @GST_FORMAT_UNDEFINED: undefined format
/// @GST_FORMAT_DEFAULT: the default format of the pad/element. This can be
/// samples for raw audio, frames/fields for raw video (some, but not all,
/// elements support this; use @GST_FORMAT_TIME if you don't have a good
/// reason to query for samples/frames)
/// @GST_FORMAT_BYTES: bytes
/// @GST_FORMAT_TIME: time in nanoseconds
/// @GST_FORMAT_BUFFERS: buffers (few, if any, elements implement this as of
/// May 2009)
/// @GST_FORMAT_PERCENT: percentage of stream (few, if any, elements implement
/// this as of May 2009)
///
/// Standard predefined formats
enum GstFormat {
  GST_FORMAT_UNDEFINED(0),
  GST_FORMAT_DEFAULT(1),
  GST_FORMAT_BYTES(2),
  GST_FORMAT_TIME(3),
  GST_FORMAT_BUFFERS(4),
  GST_FORMAT_PERCENT(5);

  final int value;
  const GstFormat(this.value);

  static GstFormat fromValue(int value) => switch (value) {
        0 => GST_FORMAT_UNDEFINED,
        1 => GST_FORMAT_DEFAULT,
        2 => GST_FORMAT_BYTES,
        3 => GST_FORMAT_TIME,
        4 => GST_FORMAT_BUFFERS,
        5 => GST_FORMAT_PERCENT,
        _ => throw ArgumentError("Unknown value for GstFormat: $value"),
      };
}

/// GstFlowReturn:
/// @GST_FLOW_OK:		 Data passing was ok.
/// @GST_FLOW_NOT_LINKED:	 Pad is not linked.
/// @GST_FLOW_FLUSHING:	         Pad is flushing.
/// @GST_FLOW_EOS:                Pad is EOS.
/// @GST_FLOW_NOT_NEGOTIATED:	 Pad is not negotiated.
/// @GST_FLOW_ERROR:		 Some (fatal) error occurred. Element generating
/// this error should post an error message using
/// GST_ELEMENT_ERROR() with more details.
/// @GST_FLOW_NOT_SUPPORTED:	 This operation is not supported.
/// @GST_FLOW_CUSTOM_SUCCESS:	 Elements can use values starting from
/// this (and higher) to define custom success
/// codes.
/// @GST_FLOW_CUSTOM_SUCCESS_1:	 Pre-defined custom success code (define your
/// custom success code to this to avoid compiler
/// warnings).
/// @GST_FLOW_CUSTOM_SUCCESS_2:	 Pre-defined custom success code.
/// @GST_FLOW_CUSTOM_ERROR:	 Elements can use values starting from
/// this (and lower) to define custom error codes.
/// @GST_FLOW_CUSTOM_ERROR_1:	 Pre-defined custom error code (define your
/// custom error code to this to avoid compiler
/// warnings).
/// @GST_FLOW_CUSTOM_ERROR_2:	 Pre-defined custom error code.
///
/// The result of passing data to a pad.
///
/// Note that the custom return values should not be exposed outside of the
/// element scope.
enum GstFlowReturn {
  GST_FLOW_CUSTOM_SUCCESS_2(102),
  GST_FLOW_CUSTOM_SUCCESS_1(101),
  GST_FLOW_CUSTOM_SUCCESS(100),
  GST_FLOW_OK(0),
  GST_FLOW_NOT_LINKED(-1),
  GST_FLOW_FLUSHING(-2),
  GST_FLOW_EOS(-3),
  GST_FLOW_NOT_NEGOTIATED(-4),
  GST_FLOW_ERROR(-5),
  GST_FLOW_NOT_SUPPORTED(-6),
  GST_FLOW_CUSTOM_ERROR(-100),
  GST_FLOW_CUSTOM_ERROR_1(-101),
  GST_FLOW_CUSTOM_ERROR_2(-102);

  final int value;
  const GstFlowReturn(this.value);

  static GstFlowReturn fromValue(int value) => switch (value) {
        102 => GST_FLOW_CUSTOM_SUCCESS_2,
        101 => GST_FLOW_CUSTOM_SUCCESS_1,
        100 => GST_FLOW_CUSTOM_SUCCESS,
        0 => GST_FLOW_OK,
        -1 => GST_FLOW_NOT_LINKED,
        -2 => GST_FLOW_FLUSHING,
        -3 => GST_FLOW_EOS,
        -4 => GST_FLOW_NOT_NEGOTIATED,
        -5 => GST_FLOW_ERROR,
        -6 => GST_FLOW_NOT_SUPPORTED,
        -100 => GST_FLOW_CUSTOM_ERROR,
        -101 => GST_FLOW_CUSTOM_ERROR_1,
        -102 => GST_FLOW_CUSTOM_ERROR_2,
        _ => throw ArgumentError("Unknown value for GstFlowReturn: $value"),
      };
}

/// GstPollFD:
/// @fd: a file descriptor
///
/// A file descriptor object.
typedef GstPollFD = imp1.GstPollFD;

/// GstBaseSrcFlags:
/// @GST_BASE_SRC_FLAG_STARTING: has source is starting
/// @GST_BASE_SRC_FLAG_STARTED: has source been started
/// @GST_BASE_SRC_FLAG_LAST: offset to define more flags
///
/// The #GstElement flags that a basesrc element may have.
enum GstBaseSrcFlags {
  GST_BASE_SRC_FLAG_STARTING(16384),
  GST_BASE_SRC_FLAG_STARTED(32768),
  GST_BASE_SRC_FLAG_LAST(1048576);

  final int value;
  const GstBaseSrcFlags(this.value);

  static GstBaseSrcFlags fromValue(int value) => switch (value) {
        16384 => GST_BASE_SRC_FLAG_STARTING,
        32768 => GST_BASE_SRC_FLAG_STARTED,
        1048576 => GST_BASE_SRC_FLAG_LAST,
        _ => throw ArgumentError("Unknown value for GstBaseSrcFlags: $value"),
      };
}

final class GstBaseSrcPrivate_ extends ffi.Opaque {}

typedef GstBaseSrcPrivate = GstBaseSrcPrivate_;

/// GstBaseSrc:
///
/// The opaque #GstBaseSrc data structure.
final class GstBaseSrc_ extends ffi.Struct {
  external imp1.GstElement element;

  external ffi.Pointer<imp1.GstPad> srcpad;

  external imp1.GMutex live_lock;

  external imp1.GCond live_cond;

  @ffi.Int()
  external int is_live;

  @ffi.Int()
  external int live_running;

  @ffi.UnsignedInt()
  external int blocksize;

  @ffi.Int()
  external int can_activate_push;

  @ffi.Int()
  external int random_access;

  external imp1.GstClockID clock_id;

  external imp1.GstSegment segment;

  @ffi.Int()
  external int need_newsegment;

  @ffi.Int()
  external int num_buffers;

  @ffi.Int()
  external int num_buffers_left;

  @ffi.Int()
  external int typefind;

  @ffi.Int()
  external int running;

  external ffi.Pointer<imp1.GstEvent> pending_seek;

  external ffi.Pointer<GstBaseSrcPrivate> priv;

  @ffi.Array.multi([20])
  external ffi.Array<ffi.Pointer> gst_reserved_;
}

typedef GstBaseSrc = GstBaseSrc_;

/// GstBaseSrcClass:
/// @parent_class: Element parent class
/// @get_caps: Called to get the caps to report
/// @negotiate: Negotiated the caps with the peer.
/// @fixate: Called during negotiation if caps need fixating. Implement instead of
/// setting a fixate function on the source pad.
/// @set_caps: Notify subclass of changed output caps
/// @decide_allocation: configure the allocation query
/// @start: Start processing. Subclasses should open resources and prepare
/// to produce data. Implementation should call gst_base_src_start_complete()
/// when the operation completes, either from the current thread or any other
/// thread that finishes the start operation asynchronously.
/// @stop: Stop processing. Subclasses should use this to close resources.
/// @get_times: Given a buffer, return the start and stop time when it
/// should be pushed out. The base class will sync on the clock using
/// these times.
/// @get_size: Return the total size of the resource, in the format set by
/// gst_base_src_set_format().
/// @is_seekable: Check if the source can seek
/// @prepare_seek_segment: Prepare the #GstSegment that will be passed to the
/// #GstBaseSrcClass::do_seek vmethod for executing a seek
/// request. Sub-classes should override this if they support seeking in
/// formats other than the configured native format. By default, it tries to
/// convert the seek arguments to the configured native format and prepare a
/// segment in that format.
/// @do_seek: Perform seeking on the resource to the indicated segment.
/// @unlock: Unlock any pending access to the resource. Subclasses should unblock
/// any blocked function ASAP. In particular, any `create()` function in
/// progress should be unblocked and should return GST_FLOW_FLUSHING. Any
/// future #GstBaseSrcClass::create function call should also return
/// GST_FLOW_FLUSHING until the #GstBaseSrcClass::unlock_stop function has
/// been called.
/// @unlock_stop: Clear the previous unlock request. Subclasses should clear any
/// state they set during #GstBaseSrcClass::unlock, such as clearing command
/// queues.
/// @query: Handle a requested query.
/// @event: Override this to implement custom event handling.
/// @create: Ask the subclass to create a buffer with offset and size.  When the
/// subclass returns GST_FLOW_OK, it MUST return a buffer of the requested size
/// unless fewer bytes are available because an EOS condition is near. No
/// buffer should be returned when the return value is different from
/// GST_FLOW_OK. A return value of GST_FLOW_EOS signifies that the end of
/// stream is reached. The default implementation will call
/// #GstBaseSrcClass::alloc and then call #GstBaseSrcClass::fill.
/// @alloc: Ask the subclass to allocate a buffer with for offset and size. The
/// default implementation will create a new buffer from the negotiated allocator.
/// @fill: Ask the subclass to fill the buffer with data for offset and size. The
/// passed buffer is guaranteed to hold the requested amount of bytes.
///
/// Subclasses can override any of the available virtual methods or not, as
/// needed. At the minimum, the @create method should be overridden to produce
/// buffers.
final class GstBaseSrcClass_ extends ffi.Struct {
  external imp1.GstElementClass parent_class;

  /// GstBaseSrcClass::get_caps:
  /// @filter: (in) (nullable):
  ///
  /// Called to get the caps to report.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<imp1.GstCaps> Function(ffi.Pointer<GstBaseSrc> src,
              ffi.Pointer<imp1.GstCaps> filter)>> get_caps;

  external ffi.Pointer<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<GstBaseSrc> src)>>
      negotiate;

  /// GstBaseSrcClass::fixate:
  /// @caps: (transfer full):
  ///
  /// Called if, in negotiation, caps need fixating.
  ///
  /// Returns: (transfer full): the fixated caps
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<imp1.GstCaps> Function(
                  ffi.Pointer<GstBaseSrc> src, ffi.Pointer<imp1.GstCaps> caps)>>
      fixate;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<GstBaseSrc> src, ffi.Pointer<imp1.GstCaps> caps)>>
      set_caps;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<GstBaseSrc> src,
              ffi.Pointer<imp1.GstQuery> query)>> decide_allocation;

  external ffi.Pointer<
      ffi.NativeFunction<ffi.Int Function(ffi.Pointer<GstBaseSrc> src)>> start;

  external ffi.Pointer<
      ffi.NativeFunction<ffi.Int Function(ffi.Pointer<GstBaseSrc> src)>> stop;

  /// GstBaseSrcClass::get_times:
  /// @start: (out):
  /// @end: (out):
  ///
  /// Given @buffer, return @start and @end time when it should be pushed
  /// out. The base class will sync on the clock using these times.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GstBaseSrc> src,
              ffi.Pointer<imp1.GstBuffer> buffer,
              ffi.Pointer<imp1.GstClockTime> start,
              ffi.Pointer<imp1.GstClockTime> end)>> get_times;

  /// GstBaseSrcClass::get_size:
  /// @size: (out):
  ///
  /// Get the total size of the resource in the format set by
  /// gst_base_src_set_format().
  ///
  /// Returns: %TRUE if the size is available and has been set.
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<GstBaseSrc> src, ffi.Pointer<ffi.Uint64> size)>>
      get_size;

  external ffi.Pointer<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<GstBaseSrc> src)>>
      is_seekable;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<GstBaseSrc> src,
              ffi.Pointer<imp1.GstEvent> seek,
              ffi.Pointer<imp1.GstSegment> segment)>> prepare_seek_segment;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<GstBaseSrc> src,
              ffi.Pointer<imp1.GstSegment> segment)>> do_seek;

  external ffi.Pointer<
      ffi.NativeFunction<ffi.Int Function(ffi.Pointer<GstBaseSrc> src)>> unlock;

  external ffi.Pointer<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<GstBaseSrc> src)>>
      unlock_stop;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<GstBaseSrc> src,
              ffi.Pointer<imp1.GstQuery> query)>> query;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<GstBaseSrc> src,
              ffi.Pointer<imp1.GstEvent> event)>> event;

  /// GstBaseSrcClass::create:
  /// @buf: (inout) (nullable):
  ///
  /// Ask the subclass to create a buffer with @offset and @size, the default
  /// implementation will call alloc if no allocated @buf is provided and then call fill.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<GstBaseSrc> src,
              ffi.Uint64 offset,
              ffi.UnsignedInt size,
              ffi.Pointer<ffi.Pointer<imp1.GstBuffer>> buf)>> create;

  /// GstBaseSrcClass::alloc:
  /// @buf: (out) (nullable):
  ///
  /// Ask the subclass to allocate an output buffer with @offset and @size, the default
  /// implementation will use the negotiated allocator.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<GstBaseSrc> src,
              ffi.Uint64 offset,
              ffi.UnsignedInt size,
              ffi.Pointer<ffi.Pointer<imp1.GstBuffer>> buf)>> alloc;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<GstBaseSrc> src, ffi.Uint64 offset,
              ffi.UnsignedInt size, ffi.Pointer<imp1.GstBuffer> buf)>> fill;

  @ffi.Array.multi([20])
  external ffi.Array<ffi.Pointer> gst_reserved_;
}

typedef GstBaseSrcClass = GstBaseSrcClass_;
typedef GstBaseSrc_autoptr = ffi.Pointer<GstBaseSrc>;
typedef GstBaseSrc_listautoptr = ffi.Pointer<imp1.GList>;
typedef GstBaseSrc_slistautoptr = ffi.Pointer<imp1.GSList>;
typedef GstBaseSrc_queueautoptr = ffi.Pointer<imp1.GQueue>;

/// GstPushSrc:
///
/// The opaque #GstPushSrc data structure.
final class GstPushSrc_ extends ffi.Struct {
  external GstBaseSrc parent;

  @ffi.Array.multi([4])
  external ffi.Array<ffi.Pointer> gst_reserved_;
}

typedef GstPushSrc = GstPushSrc_;

/// GstPushSrcClass:
/// @parent_class: Element parent class
/// @create: Ask the subclass to create a buffer. The subclass decides which
/// size this buffer should be. Other then that, refer to
/// #GstBaseSrc<!-- -->.create() for more details. If this method is
/// not implemented, @alloc followed by @fill will be called.
/// @alloc: Ask the subclass to allocate a buffer. The subclass decides which
/// size this buffer should be. The default implementation will create
/// a new buffer from the negotiated allocator.
/// @fill: Ask the subclass to fill the buffer with data.
///
/// Subclasses can override any of the available virtual methods or not, as
/// needed. At the minimum, the @fill method should be overridden to produce
/// buffers.
final class GstPushSrcClass_ extends ffi.Struct {
  external GstBaseSrcClass parent_class;

  /// GstPushSrcClass::create:
  /// @buf: (inout) (nullable):
  ///
  /// Ask the subclass to create a buffer, the default implementation will call alloc if
  /// no allocated @buf is provided and then call fill.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<GstPushSrc> src,
              ffi.Pointer<ffi.Pointer<imp1.GstBuffer>> buf)>> create;

  /// GstPushSrcClass::alloc:
  /// @buf: (out) (nullable):
  ///
  /// Allocate memory for a buffer.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<GstPushSrc> src,
              ffi.Pointer<ffi.Pointer<imp1.GstBuffer>> buf)>> alloc;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<GstPushSrc> src,
              ffi.Pointer<imp1.GstBuffer> buf)>> fill;

  @ffi.Array.multi([4])
  external ffi.Array<ffi.Pointer> gst_reserved_;
}

typedef GstPushSrcClass = GstPushSrcClass_;
typedef GstPushSrc_autoptr = ffi.Pointer<GstPushSrc>;
typedef GstPushSrc_listautoptr = ffi.Pointer<imp1.GList>;
typedef GstPushSrc_slistautoptr = ffi.Pointer<imp1.GSList>;
typedef GstPushSrc_queueautoptr = ffi.Pointer<imp1.GQueue>;

final class GstAppSrcPrivate_ extends ffi.Opaque {}

typedef GstAppSrcPrivate = GstAppSrcPrivate_;

final class GstAppSrc_ extends ffi.Struct {
  external GstBaseSrc basesrc;

  external ffi.Pointer<GstAppSrcPrivate> priv;

  @ffi.Array.multi([4])
  external ffi.Array<ffi.Pointer> gst_reserved_;
}

typedef GstAppSrc = GstAppSrc_;

final class GstAppSrcClass_ extends ffi.Struct {
  external GstBaseSrcClass basesrc_class;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<GstAppSrc> appsrc, ffi.UnsignedInt length)>>
      need_data;

  external ffi.Pointer<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GstAppSrc> appsrc)>>
      enough_data;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<GstAppSrc> appsrc, ffi.Uint64 offset)>> seek_data;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<GstAppSrc> appsrc,
              ffi.Pointer<imp1.GstBuffer> buffer)>> push_buffer;

  external ffi.Pointer<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<GstAppSrc> appsrc)>>
      end_of_stream;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<GstAppSrc> appsrc,
              ffi.Pointer<imp1.GstSample> sample)>> push_sample;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<GstAppSrc> appsrc,
              ffi.Pointer<imp1.GstBufferList> buffer_list)>> push_buffer_list;

  @ffi.Array.multi([2])
  external ffi.Array<ffi.Pointer> gst_reserved_;
}

typedef GstAppSrcClass = GstAppSrcClass_;

/// GstAppSrcCallbacks: (skip)
/// @need_data: Called when the appsrc needs more data. A buffer or EOS should be
/// pushed to appsrc from this thread or another thread. @length is just a hint
/// and when it is set to -1, any number of bytes can be pushed into @appsrc.
/// @enough_data: Called when appsrc has enough data. It is recommended that the
/// application stops calling push-buffer until the need_data callback is
/// emitted again to avoid excessive buffer queueing.
/// @seek_data: Called when a seek should be performed to the offset.
/// The next push-buffer should produce buffers from the new @offset.
/// This callback is only called for seekable stream types.
///
/// A set of callbacks that can be installed on the appsrc with
/// gst_app_src_set_callbacks().
final class GstAppSrcCallbacks extends ffi.Struct {
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GstAppSrc> src, ffi.UnsignedInt length,
              ffi.Pointer user_data)>> need_data;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GstAppSrc> src, ffi.Pointer user_data)>> enough_data;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<GstAppSrc> src, ffi.Uint64 offset,
              ffi.Pointer user_data)>> seek_data;

  @ffi.Array.multi([4])
  external ffi.Array<ffi.Pointer> gst_reserved_;
}

/// GstAppStreamType:
/// @GST_APP_STREAM_TYPE_STREAM: No seeking is supported in the stream, such as a
/// live stream.
/// @GST_APP_STREAM_TYPE_SEEKABLE: The stream is seekable but seeking might not
/// be very fast, such as data from a webserver.
/// @GST_APP_STREAM_TYPE_RANDOM_ACCESS: The stream is seekable and seeking is fast,
/// such as in a local file.
///
/// The stream type.
enum GstAppStreamType {
  GST_APP_STREAM_TYPE_STREAM(0),
  GST_APP_STREAM_TYPE_SEEKABLE(1),
  GST_APP_STREAM_TYPE_RANDOM_ACCESS(2);

  final int value;
  const GstAppStreamType(this.value);

  static GstAppStreamType fromValue(int value) => switch (value) {
        0 => GST_APP_STREAM_TYPE_STREAM,
        1 => GST_APP_STREAM_TYPE_SEEKABLE,
        2 => GST_APP_STREAM_TYPE_RANDOM_ACCESS,
        _ => throw ArgumentError("Unknown value for GstAppStreamType: $value"),
      };
}

/// GstAppLeakyType:
/// @GST_APP_LEAKY_TYPE_NONE: Not Leaky
/// @GST_APP_LEAKY_TYPE_UPSTREAM: Leaky on upstream (new buffers)
/// @GST_APP_LEAKY_TYPE_DOWNSTREAM: Leaky on downstream (old buffers)
///
/// Buffer dropping scheme to avoid the element's internal queue to block when
/// full.
///
/// Since: 1.20
enum GstAppLeakyType {
  GST_APP_LEAKY_TYPE_NONE(0),
  GST_APP_LEAKY_TYPE_UPSTREAM(1),
  GST_APP_LEAKY_TYPE_DOWNSTREAM(2);

  final int value;
  const GstAppLeakyType(this.value);

  static GstAppLeakyType fromValue(int value) => switch (value) {
        0 => GST_APP_LEAKY_TYPE_NONE,
        1 => GST_APP_LEAKY_TYPE_UPSTREAM,
        2 => GST_APP_LEAKY_TYPE_DOWNSTREAM,
        _ => throw ArgumentError("Unknown value for GstAppLeakyType: $value"),
      };
}

typedef GstAppSrc_autoptr = ffi.Pointer<GstAppSrc>;
typedef GstAppSrc_listautoptr = ffi.Pointer<imp1.GList>;
typedef GstAppSrc_slistautoptr = ffi.Pointer<imp1.GSList>;
typedef GstAppSrc_queueautoptr = ffi.Pointer<imp1.GQueue>;

final class GstBaseSinkPrivate_ extends ffi.Opaque {}

typedef GstBaseSinkPrivate = GstBaseSinkPrivate_;

/// GstBaseSink:
///
/// The opaque #GstBaseSink data structure.
final class GstBaseSink_ extends ffi.Struct {
  external imp1.GstElement element;

  external ffi.Pointer<imp1.GstPad> sinkpad;

  @ffi.UnsignedInt()
  external int pad_modeAsInt;

  GstPadMode get pad_mode => GstPadMode.fromValue(pad_modeAsInt);

  @ffi.Uint64()
  external int offset;

  @ffi.Int()
  external int can_activate_pull;

  @ffi.Int()
  external int can_activate_push;

  external imp1.GMutex preroll_lock;

  external imp1.GCond preroll_cond;

  @ffi.Int()
  external int eos;

  @ffi.Int()
  external int need_preroll;

  @ffi.Int()
  external int have_preroll;

  @ffi.Int()
  external int playing_async;

  @ffi.Int()
  external int have_newsegment;

  external imp1.GstSegment segment;

  external imp1.GstClockID clock_id;

  @ffi.Int()
  external int sync1;

  @ffi.Int()
  external int flushing;

  @ffi.Int()
  external int running;

  @ffi.Int64()
  external int max_lateness;

  external ffi.Pointer<GstBaseSinkPrivate> priv;

  @ffi.Array.multi([20])
  external ffi.Array<ffi.Pointer> gst_reserved_;
}

typedef GstBaseSink = GstBaseSink_;

/// GstBaseSinkClass:
/// @parent_class: Element parent class
/// @get_caps: Called to get sink pad caps from the subclass
/// @set_caps: Notify subclass of changed caps
/// @fixate: Only useful in pull mode. Implement if you have
/// ideas about what should be the default values for the caps you support.
/// @activate_pull: Subclasses should override this when they can provide an
/// alternate method of spawning a thread to drive the pipeline in pull mode.
/// Should start or stop the pulling thread, depending on the value of the
/// "active" argument. Called after actually activating the sink pad in pull
/// mode. The default implementation starts a task on the sink pad.
/// @get_times: Called to get the start and end times for synchronising
/// the passed buffer to the clock
/// @propose_allocation: configure the allocation query
/// @start: Start processing. Ideal for opening resources in the subclass
/// @stop: Stop processing. Subclasses should use this to close resources.
/// @unlock: Unlock any pending access to the resource. Subclasses should
/// unblock any blocked function ASAP and call gst_base_sink_wait_preroll()
/// @unlock_stop: Clear the previous unlock request. Subclasses should clear
/// any state they set during #GstBaseSinkClass::unlock, and be ready to
/// continue where they left off after gst_base_sink_wait_preroll(),
/// gst_base_sink_wait() or gst_wait_sink_wait_clock() return or
/// #GstBaseSinkClass::render is called again.
/// @query: perform a #GstQuery on the element.
/// @event: Override this to handle events arriving on the sink pad
/// @wait_event: Override this to implement custom logic to wait for the event
/// time (for events like EOS and GAP). Subclasses should always first
/// chain up to the default implementation.
/// @prepare: Called to prepare the buffer for @render and @preroll. This
/// function is called before synchronisation is performed.
/// @prepare_list: Called to prepare the buffer list for @render_list. This
/// function is called before synchronisation is performed.
/// @preroll: Called to present the preroll buffer if desired.
/// @render: Called when a buffer should be presented or output, at the
/// correct moment if the #GstBaseSink has been set to sync to the clock.
/// @render_list: Same as @render but used with buffer lists instead of
/// buffers.
///
/// Subclasses can override any of the available virtual methods or not, as
/// needed. At the minimum, the @render method should be overridden to
/// output/present buffers.
final class GstBaseSinkClass_ extends ffi.Struct {
  external imp1.GstElementClass parent_class;

  /// GstBaseSinkClass::get_caps:
  /// @filter: (in) (nullable):
  ///
  /// Called to get sink pad caps from the subclass.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<imp1.GstCaps> Function(ffi.Pointer<GstBaseSink> sink,
              ffi.Pointer<imp1.GstCaps> filter)>> get_caps;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<GstBaseSink> sink,
              ffi.Pointer<imp1.GstCaps> caps)>> set_caps;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<imp1.GstCaps> Function(ffi.Pointer<GstBaseSink> sink,
              ffi.Pointer<imp1.GstCaps> caps)>> fixate;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<GstBaseSink> sink, ffi.Int active)>>
      activate_pull;

  /// GstBaseSinkClass::get_times:
  /// @start: (out): the start #GstClockTime
  /// @end: (out): the end #GstClockTime
  ///
  /// Get the start and end times for syncing on this buffer.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GstBaseSink> sink,
              ffi.Pointer<imp1.GstBuffer> buffer,
              ffi.Pointer<imp1.GstClockTime> start,
              ffi.Pointer<imp1.GstClockTime> end)>> get_times;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<GstBaseSink> sink,
              ffi.Pointer<imp1.GstQuery> query)>> propose_allocation;

  external ffi.Pointer<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<GstBaseSink> sink)>>
      start;

  external ffi.Pointer<
      ffi.NativeFunction<ffi.Int Function(ffi.Pointer<GstBaseSink> sink)>> stop;

  external ffi.Pointer<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<GstBaseSink> sink)>>
      unlock;

  external ffi.Pointer<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<GstBaseSink> sink)>>
      unlock_stop;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<GstBaseSink> sink,
              ffi.Pointer<imp1.GstQuery> query)>> query;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<GstBaseSink> sink,
              ffi.Pointer<imp1.GstEvent> event)>> event;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<GstBaseSink> sink,
              ffi.Pointer<imp1.GstEvent> event)>> wait_event;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<GstBaseSink> sink,
              ffi.Pointer<imp1.GstBuffer> buffer)>> prepare;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<GstBaseSink> sink,
              ffi.Pointer<imp1.GstBufferList> buffer_list)>> prepare_list;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<GstBaseSink> sink,
              ffi.Pointer<imp1.GstBuffer> buffer)>> preroll;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<GstBaseSink> sink,
              ffi.Pointer<imp1.GstBuffer> buffer)>> render;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<GstBaseSink> sink,
              ffi.Pointer<imp1.GstBufferList> buffer_list)>> render_list;

  @ffi.Array.multi([20])
  external ffi.Array<ffi.Pointer> gst_reserved_;
}

typedef GstBaseSinkClass = GstBaseSinkClass_;
typedef GstBaseSink_autoptr = ffi.Pointer<GstBaseSink>;
typedef GstBaseSink_listautoptr = ffi.Pointer<imp1.GList>;
typedef GstBaseSink_slistautoptr = ffi.Pointer<imp1.GSList>;
typedef GstBaseSink_queueautoptr = ffi.Pointer<imp1.GQueue>;

final class GstAppSinkPrivate_ extends ffi.Opaque {}

typedef GstAppSinkPrivate = GstAppSinkPrivate_;

final class GstAppSink_ extends ffi.Struct {
  external GstBaseSink basesink;

  external ffi.Pointer<GstAppSinkPrivate> priv;

  @ffi.Array.multi([4])
  external ffi.Array<ffi.Pointer> gst_reserved_;
}

typedef GstAppSink = GstAppSink_;

final class GstAppSinkClass_ extends ffi.Struct {
  external GstBaseSinkClass basesink_class;

  external ffi.Pointer<
      ffi
      .NativeFunction<ffi.Void Function(ffi.Pointer<GstAppSink> appsink)>> eos;

  external ffi.Pointer<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<GstAppSink> appsink)>>
      new_preroll;

  external ffi.Pointer<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<GstAppSink> appsink)>>
      new_sample;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<imp1.GstSample> Function(
              ffi.Pointer<GstAppSink> appsink)>> pull_preroll;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<imp1.GstSample> Function(
              ffi.Pointer<GstAppSink> appsink)>> pull_sample;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<imp1.GstSample> Function(
                  ffi.Pointer<GstAppSink> appsink, imp1.GstClockTime timeout)>>
      try_pull_preroll;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<imp1.GstSample> Function(
                  ffi.Pointer<GstAppSink> appsink, imp1.GstClockTime timeout)>>
      try_pull_sample;

  /// GstAppSinkClass::try_pull_object:
  ///
  /// See #GstAppSink::try-pull-object: signal.
  ///
  /// Since: 1.20
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<imp1.GstMiniObject1> Function(
                  ffi.Pointer<GstAppSink> appsink, imp1.GstClockTime timeout)>>
      try_pull_object;

  @ffi.Array.multi([1])
  external ffi.Array<ffi.Pointer> gst_reserved_;
}

typedef GstAppSinkClass = GstAppSinkClass_;

/// GstAppSinkCallbacks: (skip)
/// @eos: Called when the end-of-stream has been reached. This callback
/// is called from the streaming thread.
/// @new_preroll: Called when a new preroll sample is available.
/// This callback is called from the streaming thread.
/// The new preroll sample can be retrieved with
/// gst_app_sink_pull_preroll() either from this callback
/// or from any other thread.
/// @new_sample: Called when a new sample is available.
/// This callback is called from the streaming thread.
/// The new sample can be retrieved with
/// gst_app_sink_pull_sample() either from this callback
/// or from any other thread.
/// @new_event: Called when a new event is available.
/// This callback is called from the streaming thread.
/// The new event can be retrieved with
/// gst_app_sink_pull_event() either from this callback
/// or from any other thread.
/// The callback should return %TRUE if the event has been handled,
/// %FALSE otherwise.
/// Since: 1.20
/// @propose_allocation: Called when the propose_allocation query is available.
/// This callback is called from the streaming thread.
/// The allocation query can be retrieved with
/// gst_app_sink_propose_allocation() either from this callback
/// or from any other thread.
/// Since: 1.24
///
/// A set of callbacks that can be installed on the appsink with
/// gst_app_sink_set_callbacks().
final class GstAppSinkCallbacks extends ffi.Struct {
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GstAppSink> appsink, ffi.Pointer user_data)>> eos;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<GstAppSink> appsink, ffi.Pointer user_data)>>
      new_preroll;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<GstAppSink> appsink, ffi.Pointer user_data)>>
      new_sample;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<GstAppSink> appsink, ffi.Pointer user_data)>>
      new_event;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<GstAppSink> appsink,
              ffi.Pointer<imp1.GstQuery> query,
              ffi.Pointer user_data)>> propose_allocation;

  @ffi.Array.multi([2])
  external ffi.Array<ffi.Pointer> gst_reserved_;
}

typedef GstAppSink_autoptr = ffi.Pointer<GstAppSink>;
typedef GstAppSink_listautoptr = ffi.Pointer<imp1.GList>;
typedef GstAppSink_slistautoptr = ffi.Pointer<imp1.GSList>;
typedef GstAppSink_queueautoptr = ffi.Pointer<imp1.GQueue>;

const int NULL = 0;

const int g_macro__has_attribute = 0;

const int g_macro__has_feature = 0;

const int g_macro__has_builtin = 0;

const int g_macro__has_extension = 0;

const String G_GNUC_FUNCTION = '';

const String G_GNUC_PRETTY_FUNCTION = '';

const int G_ANALYZER_ANALYZING = 0;

const int FALSE = 0;

const int TRUE = 1;

const int G_HAVE_GNUC_VISIBILITY = 1;

const int _LIBC_LIMITS_H_ = 1;

const int _FEATURES_H = 1;

const int _DEFAULT_SOURCE = 1;

const int __GLIBC_USE_ISOC23 = 1;

const int __USE_ISOC11 = 1;

const int __USE_ISOC99 = 1;

const int __USE_ISOC95 = 1;

const int _POSIX_SOURCE = 1;

const int _POSIX_C_SOURCE = 200809;

const int __USE_POSIX = 1;

const int __USE_POSIX2 = 1;

const int __USE_POSIX199309 = 1;

const int __USE_POSIX199506 = 1;

const int __USE_XOPEN2K = 1;

const int __USE_XOPEN2K8 = 1;

const int _ATFILE_SOURCE = 1;

const int __WORDSIZE = 64;

const int __WORDSIZE_TIME64_COMPAT32 = 1;

const int __SYSCALL_WORDSIZE = 64;

const int __TIMESIZE = 64;

const int __USE_TIME_BITS64 = 1;

const int __USE_MISC = 1;

const int __USE_ATFILE = 1;

const int __USE_FORTIFY_LEVEL = 0;

const int __GLIBC_USE_DEPRECATED_GETS = 0;

const int __GLIBC_USE_DEPRECATED_SCANF = 0;

const int __GLIBC_USE_C23_STRTOL = 1;

const int _STDC_PREDEF_H = 1;

const int __STDC_IEC_559__ = 1;

const int __STDC_IEC_60559_BFP__ = 201404;

const int __STDC_IEC_559_COMPLEX__ = 1;

const int __STDC_IEC_60559_COMPLEX__ = 201404;

const int __STDC_ISO_10646__ = 201706;

const int __GNU_LIBRARY__ = 6;

const int __GLIBC__ = 2;

const int __GLIBC_MINOR__ = 40;

const int _SYS_CDEFS_H = 1;

const int __THROW = 1;

const int __THROWNL = 1;

const int __glibc_c99_flexarr_available = 1;

const int __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI = 0;

const int __HAVE_GENERIC_SELECTION = 0;

const int __GLIBC_USE_LIB_EXT2 = 1;

const int __GLIBC_USE_IEC_60559_BFP_EXT = 1;

const int __GLIBC_USE_IEC_60559_BFP_EXT_C23 = 1;

const int __GLIBC_USE_IEC_60559_EXT = 1;

const int __GLIBC_USE_IEC_60559_FUNCS_EXT = 1;

const int __GLIBC_USE_IEC_60559_FUNCS_EXT_C23 = 1;

const int __GLIBC_USE_IEC_60559_TYPES_EXT = 1;

const int MB_LEN_MAX = 16;

const int LLONG_MIN = -9223372036854775808;

const int LLONG_MAX = 9223372036854775807;

const int ULLONG_MAX = -1;

const int _BITS_POSIX1_LIM_H = 1;

const int _POSIX_AIO_LISTIO_MAX = 2;

const int _POSIX_AIO_MAX = 1;

const int _POSIX_ARG_MAX = 4096;

const int _POSIX_CHILD_MAX = 25;

const int _POSIX_DELAYTIMER_MAX = 32;

const int _POSIX_HOST_NAME_MAX = 255;

const int _POSIX_LINK_MAX = 8;

const int _POSIX_LOGIN_NAME_MAX = 9;

const int _POSIX_MAX_CANON = 255;

const int _POSIX_MAX_INPUT = 255;

const int _POSIX_MQ_OPEN_MAX = 8;

const int _POSIX_MQ_PRIO_MAX = 32;

const int _POSIX_NAME_MAX = 14;

const int _POSIX_NGROUPS_MAX = 8;

const int _POSIX_OPEN_MAX = 20;

const int _POSIX_PATH_MAX = 256;

const int _POSIX_PIPE_BUF = 512;

const int _POSIX_RE_DUP_MAX = 255;

const int _POSIX_RTSIG_MAX = 8;

const int _POSIX_SEM_NSEMS_MAX = 256;

const int _POSIX_SEM_VALUE_MAX = 32767;

const int _POSIX_SIGQUEUE_MAX = 32;

const int _POSIX_SSIZE_MAX = 32767;

const int _POSIX_STREAM_MAX = 8;

const int _POSIX_SYMLINK_MAX = 255;

const int _POSIX_SYMLOOP_MAX = 8;

const int _POSIX_TIMER_MAX = 32;

const int _POSIX_TTY_NAME_MAX = 9;

const int _POSIX_TZNAME_MAX = 6;

const int _POSIX_CLOCKRES_MIN = 20000000;

const int NGROUPS_MAX = 65536;

const int MAX_CANON = 255;

const int MAX_INPUT = 255;

const int NAME_MAX = 255;

const int PATH_MAX = 4096;

const int PIPE_BUF = 4096;

const int XATTR_NAME_MAX = 255;

const int XATTR_SIZE_MAX = 65536;

const int XATTR_LIST_MAX = 65536;

const int RTSIG_MAX = 32;

const int _POSIX_THREAD_KEYS_MAX = 128;

const int PTHREAD_KEYS_MAX = 1024;

const int _POSIX_THREAD_DESTRUCTOR_ITERATIONS = 4;

const int PTHREAD_DESTRUCTOR_ITERATIONS = 4;

const int _POSIX_THREAD_THREADS_MAX = 64;

const int AIO_PRIO_DELTA_MAX = 20;

const int DELAYTIMER_MAX = 2147483647;

const int TTY_NAME_MAX = 32;

const int LOGIN_NAME_MAX = 256;

const int HOST_NAME_MAX = 64;

const int MQ_PRIO_MAX = 32768;

const int SEM_VALUE_MAX = 2147483647;

const int SSIZE_MAX = 9223372036854775807;

const int _BITS_POSIX2_LIM_H = 1;

const int _POSIX2_BC_BASE_MAX = 99;

const int _POSIX2_BC_DIM_MAX = 2048;

const int _POSIX2_BC_SCALE_MAX = 99;

const int _POSIX2_BC_STRING_MAX = 1000;

const int _POSIX2_COLL_WEIGHTS_MAX = 2;

const int _POSIX2_EXPR_NEST_MAX = 32;

const int _POSIX2_LINE_MAX = 2048;

const int _POSIX2_RE_DUP_MAX = 255;

const int _POSIX2_CHARCLASS_NAME_MAX = 14;

const int BC_BASE_MAX = 99;

const int BC_DIM_MAX = 2048;

const int BC_SCALE_MAX = 99;

const int BC_STRING_MAX = 1000;

const int COLL_WEIGHTS_MAX = 255;

const int EXPR_NEST_MAX = 32;

const int LINE_MAX = 2048;

const int CHARCLASS_NAME_MAX = 2048;

const int RE_DUP_MAX = 32767;

const int SCHAR_MAX = 127;

const int SHRT_MAX = 32767;

const int INT_MAX = 2147483647;

const int LONG_MAX = 9223372036854775807;

const int SCHAR_MIN = -128;

const int SHRT_MIN = -32768;

const int INT_MIN = -2147483648;

const int LONG_MIN = -9223372036854775808;

const int UCHAR_MAX = 255;

const int USHRT_MAX = 65535;

const int UINT_MAX = 4294967295;

const int ULONG_MAX = -1;

const int CHAR_BIT = 8;

const int CHAR_MIN = -128;

const int CHAR_MAX = 127;

const int FLT_EVAL_METHOD = 0;

const int FLT_RADIX = 2;

const int FLT_MANT_DIG = 24;

const int DBL_MANT_DIG = 53;

const int LDBL_MANT_DIG = 64;

const int DECIMAL_DIG = 21;

const int FLT_DIG = 6;

const int DBL_DIG = 15;

const int LDBL_DIG = 18;

const int FLT_MIN_EXP = -125;

const int DBL_MIN_EXP = -1021;

const int LDBL_MIN_EXP = -16381;

const int FLT_MIN_10_EXP = -37;

const int DBL_MIN_10_EXP = -307;

const int LDBL_MIN_10_EXP = -4931;

const int FLT_MAX_EXP = 128;

const int DBL_MAX_EXP = 1024;

const int LDBL_MAX_EXP = 16384;

const int FLT_MAX_10_EXP = 38;

const int DBL_MAX_10_EXP = 308;

const int LDBL_MAX_10_EXP = 4932;

const double FLT_MAX = 3.4028234663852886e+38;

const double DBL_MAX = 1.7976931348623157e+308;

const double LDBL_MAX = double.infinity;

const double FLT_EPSILON = 1.1920928955078125e-7;

const double DBL_EPSILON = 2.220446049250313e-16;

const double LDBL_EPSILON = 1.0842021724855044e-19;

const double FLT_MIN = 1.1754943508222875e-38;

const double DBL_MIN = 2.2250738585072014e-308;

const double LDBL_MIN = 0.0;

const double FLT_TRUE_MIN = 1.401298464324817e-45;

const double DBL_TRUE_MIN = 5e-324;

const double LDBL_TRUE_MIN = 0.0;

const int FLT_DECIMAL_DIG = 9;

const int DBL_DECIMAL_DIG = 17;

const int LDBL_DECIMAL_DIG = 21;

const int FLT_HAS_SUBNORM = 1;

const int DBL_HAS_SUBNORM = 1;

const int LDBL_HAS_SUBNORM = 1;

const double INFINITY = double.infinity;

const double NAN = double.nan;

const double FLT_NORM_MAX = 3.4028234663852886e+38;

const double DBL_NORM_MAX = 1.7976931348623157e+308;

const double LDBL_NORM_MAX = double.infinity;

const double G_MINFLOAT = 1.1754943508222875e-38;

const double G_MAXFLOAT = 3.4028234663852886e+38;

const double G_MINDOUBLE = 2.2250738585072014e-308;

const double G_MAXDOUBLE = 1.7976931348623157e+308;

const int G_MINSHORT = -32768;

const int G_MAXSHORT = 32767;

const int G_MAXUSHORT = 65535;

const int G_MININT = -2147483648;

const int G_MAXINT = 2147483647;

const int G_MAXUINT = 4294967295;

const int G_MINLONG = -9223372036854775808;

const int G_MAXLONG = 9223372036854775807;

const int G_MAXULONG = -1;

const String G_GINT16_MODIFIER = 'h';

const String G_GINT16_FORMAT = 'hi';

const String G_GUINT16_FORMAT = 'hu';

const String G_GINT32_MODIFIER = '';

const String G_GINT32_FORMAT = 'i';

const String G_GUINT32_FORMAT = 'u';

const int G_HAVE_GINT64 = 1;

const String G_GINT64_MODIFIER = 'l';

const String G_GINT64_FORMAT = 'li';

const String G_GUINT64_FORMAT = 'lu';

const int GLIB_SIZEOF_VOID_P = 8;

const int GLIB_SIZEOF_LONG = 8;

const int GLIB_SIZEOF_SIZE_T = 8;

const int GLIB_SIZEOF_SSIZE_T = 8;

const String G_GSIZE_MODIFIER = 'l';

const String G_GSSIZE_MODIFIER = 'l';

const String G_GSIZE_FORMAT = 'lu';

const String G_GSSIZE_FORMAT = 'li';

const int G_MAXSIZE = -1;

const int G_MINSSIZE = -9223372036854775808;

const int G_MAXSSIZE = 9223372036854775807;

const int G_MINOFFSET = -9223372036854775808;

const int G_MAXOFFSET = 9223372036854775807;

const String G_GOFFSET_MODIFIER = 'l';

const String G_GOFFSET_FORMAT = 'li';

const String G_POLLFD_FORMAT = '%d';

const String G_GINTPTR_MODIFIER = 'l';

const String G_GINTPTR_FORMAT = 'li';

const String G_GUINTPTR_FORMAT = 'lu';

const int GLIB_MAJOR_VERSION = 2;

const int GLIB_MINOR_VERSION = 82;

const int GLIB_MICRO_VERSION = 4;

const int G_VA_COPY_AS_ARRAY = 1;

const int G_HAVE_ISO_VARARGS = 1;

const int G_HAVE_GROWING_STACK = 0;

const int G_HAVE_GNUC_VARARGS = 1;

const int G_BYTE_ORDER = 1234;

const String G_MODULE_SUFFIX = 'so';

const String G_PID_FORMAT = 'i';

const int GLIB_SYSDEF_AF_UNIX = 1;

const int GLIB_SYSDEF_AF_INET = 2;

const int GLIB_SYSDEF_AF_INET6 = 10;

const int GLIB_SYSDEF_MSG_OOB = 1;

const int GLIB_SYSDEF_MSG_PEEK = 2;

const int GLIB_SYSDEF_MSG_DONTROUTE = 4;

const int G_DIR_SEPARATOR = 47;

const String G_DIR_SEPARATOR_S = '/';

const int G_SEARCHPATH_SEPARATOR = 58;

const String G_SEARCHPATH_SEPARATOR_S = ':';

const int GLIB_VERSION_2_2 = 131584;

const int GLIB_VERSION_2_4 = 132096;

const int GLIB_VERSION_2_6 = 132608;

const int GLIB_VERSION_2_8 = 133120;

const int GLIB_VERSION_2_10 = 133632;

const int GLIB_VERSION_2_12 = 134144;

const int GLIB_VERSION_2_14 = 134656;

const int GLIB_VERSION_2_16 = 135168;

const int GLIB_VERSION_2_18 = 135680;

const int GLIB_VERSION_2_20 = 136192;

const int GLIB_VERSION_2_22 = 136704;

const int GLIB_VERSION_2_24 = 137216;

const int GLIB_VERSION_2_26 = 137728;

const int GLIB_VERSION_2_28 = 138240;

const int GLIB_VERSION_2_30 = 138752;

const int GLIB_VERSION_2_32 = 139264;

const int GLIB_VERSION_2_34 = 139776;

const int GLIB_VERSION_2_36 = 140288;

const int GLIB_VERSION_2_38 = 140800;

const int GLIB_VERSION_2_40 = 141312;

const int GLIB_VERSION_2_42 = 141824;

const int GLIB_VERSION_2_44 = 142336;

const int GLIB_VERSION_2_46 = 142848;

const int GLIB_VERSION_2_48 = 143360;

const int GLIB_VERSION_2_50 = 143872;

const int GLIB_VERSION_2_52 = 144384;

const int GLIB_VERSION_2_54 = 144896;

const int GLIB_VERSION_2_56 = 145408;

const int GLIB_VERSION_2_58 = 145920;

const int GLIB_VERSION_2_60 = 146432;

const int GLIB_VERSION_2_62 = 146944;

const int GLIB_VERSION_2_64 = 147456;

const int GLIB_VERSION_2_66 = 147968;

const int GLIB_VERSION_2_68 = 148480;

const int GLIB_VERSION_2_70 = 148992;

const int GLIB_VERSION_2_72 = 149504;

const int GLIB_VERSION_2_74 = 150016;

const int GLIB_VERSION_2_76 = 150528;

const int GLIB_VERSION_2_78 = 151040;

const int GLIB_VERSION_2_80 = 151552;

const int GLIB_VERSION_2_82 = 152064;

const int GLIB_VERSION_CUR_STABLE = 152064;

const int GLIB_VERSION_PREV_STABLE = 151552;

const int GLIB_VERSION_MIN_REQUIRED = 152064;

const int GLIB_VERSION_MAX_ALLOWED = 152064;

const int _TIME_H = 1;

const int _BITS_TIME_H = 1;

const int _BITS_TYPES_H = 1;

const int _BITS_TYPESIZES_H = 1;

const int __OFF_T_MATCHES_OFF64_T = 1;

const int __INO_T_MATCHES_INO64_T = 1;

const int __RLIM_T_MATCHES_RLIM64_T = 1;

const int __STATFS_MATCHES_STATFS64 = 1;

const int __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64 = 1;

const int __FD_SETSIZE = 1024;

const int _BITS_TIME64_H = 1;

const int CLOCKS_PER_SEC = 1000000;

const int CLOCK_REALTIME = 0;

const int CLOCK_MONOTONIC = 1;

const int CLOCK_PROCESS_CPUTIME_ID = 2;

const int CLOCK_THREAD_CPUTIME_ID = 3;

const int CLOCK_MONOTONIC_RAW = 4;

const int CLOCK_REALTIME_COARSE = 5;

const int CLOCK_MONOTONIC_COARSE = 6;

const int CLOCK_BOOTTIME = 7;

const int CLOCK_REALTIME_ALARM = 8;

const int CLOCK_BOOTTIME_ALARM = 9;

const int CLOCK_TAI = 11;

const int TIMER_ABSTIME = 1;

const int __clock_t_defined = 1;

const int __time_t_defined = 1;

const int __struct_tm_defined = 1;

const int _STRUCT_TIMESPEC = 1;

const int _BITS_ENDIAN_H = 1;

const int __LITTLE_ENDIAN = 1234;

const int __BIG_ENDIAN = 4321;

const int __PDP_ENDIAN = 3412;

const int _BITS_ENDIANNESS_H = 1;

const int __BYTE_ORDER = 1234;

const int __FLOAT_WORD_ORDER = 1234;

const int __clockid_t_defined = 1;

const int __timer_t_defined = 1;

const int __itimerspec_defined = 1;

const int _BITS_TYPES_LOCALE_T_H = 1;

const int _BITS_TYPES___LOCALE_T_H = 1;

const int TIME_UTC = 1;

const int G_MININT8 = -128;

const int G_MAXINT8 = 127;

const int G_MAXUINT8 = 255;

const int G_MININT16 = -32768;

const int G_MAXINT16 = 32767;

const int G_MAXUINT16 = 65535;

const int G_MININT32 = -2147483648;

const int G_MAXINT32 = 2147483647;

const int G_MAXUINT32 = 4294967295;

const int G_MININT64 = -9223372036854775808;

const int G_MAXINT64 = 9223372036854775807;

const int G_MAXUINT64 = -1;

const double G_E = 2.718281828459045;

const double G_LN2 = 0.6931471805599453;

const double G_LN10 = 2.302585092994046;

const double G_PI = 3.141592653589793;

const double G_PI_2 = 1.5707963267948966;

const double G_PI_4 = 0.7853981633974483;

const double G_SQRT2 = 1.4142135623730951;

const int G_LITTLE_ENDIAN = 1234;

const int G_BIG_ENDIAN = 4321;

const int G_PDP_ENDIAN = 3412;

const int G_IEEE754_FLOAT_BIAS = 127;

const int G_IEEE754_DOUBLE_BIAS = 1023;

const double G_LOG_2_BASE_10 = 0.3010299956639812;

const int _STRING_H = 1;

const int _STRINGS_H = 1;

const String G_OS_INFO_KEY_NAME = 'NAME';

const String G_OS_INFO_KEY_PRETTY_NAME = 'PRETTY_NAME';

const String G_OS_INFO_KEY_VERSION = 'VERSION';

const String G_OS_INFO_KEY_VERSION_CODENAME = 'VERSION_CODENAME';

const String G_OS_INFO_KEY_VERSION_ID = 'VERSION_ID';

const String G_OS_INFO_KEY_ID = 'ID';

const String G_OS_INFO_KEY_HOME_URL = 'HOME_URL';

const String G_OS_INFO_KEY_DOCUMENTATION_URL = 'DOCUMENTATION_URL';

const String G_OS_INFO_KEY_SUPPORT_URL = 'SUPPORT_URL';

const String G_OS_INFO_KEY_BUG_REPORT_URL = 'BUG_REPORT_URL';

const String G_OS_INFO_KEY_PRIVACY_POLICY_URL = 'PRIVACY_POLICY_URL';

const int _STDLIB_H = 1;

const int WNOHANG = 1;

const int WUNTRACED = 2;

const int WSTOPPED = 2;

const int WEXITED = 4;

const int WCONTINUED = 8;

const int WNOWAIT = 16777216;

const int __WNOTHREAD = 536870912;

const int __WALL = 1073741824;

const int __WCLONE = 2147483648;

const int __W_CONTINUED = 65535;

const int __WCOREFLAG = 128;

const int __HAVE_FLOAT128 = 0;

const int __HAVE_DISTINCT_FLOAT128 = 0;

const int __HAVE_FLOAT64X = 1;

const int __HAVE_FLOAT64X_LONG_DOUBLE = 1;

const int __HAVE_FLOAT16 = 0;

const int __HAVE_FLOAT32 = 1;

const int __HAVE_FLOAT64 = 1;

const int __HAVE_FLOAT32X = 1;

const int __HAVE_FLOAT128X = 0;

const int __HAVE_DISTINCT_FLOAT16 = 0;

const int __HAVE_DISTINCT_FLOAT32 = 0;

const int __HAVE_DISTINCT_FLOAT64 = 0;

const int __HAVE_DISTINCT_FLOAT32X = 0;

const int __HAVE_DISTINCT_FLOAT64X = 0;

const int __HAVE_DISTINCT_FLOAT128X = 0;

const int __HAVE_FLOAT128_UNLIKE_LDBL = 0;

const int __HAVE_FLOATN_NOT_TYPEDEF = 0;

const int __ldiv_t_defined = 1;

const int __lldiv_t_defined = 1;

const int RAND_MAX = 2147483647;

const int EXIT_FAILURE = 1;

const int EXIT_SUCCESS = 0;

const int _SYS_TYPES_H = 1;

const int _BITS_STDINT_INTN_H = 1;

const int __BIT_TYPES_DEFINED__ = 1;

const int _ENDIAN_H = 1;

const int LITTLE_ENDIAN = 1234;

const int BIG_ENDIAN = 4321;

const int PDP_ENDIAN = 3412;

const int BYTE_ORDER = 1234;

const int _BITS_BYTESWAP_H = 1;

const int _BITS_UINTN_IDENTITY_H = 1;

const int _SYS_SELECT_H = 1;

const int __sigset_t_defined = 1;

const int _SIGSET_NWORDS = 16;

const int __timeval_defined = 1;

const int __NFDBITS = 64;

const int FD_SETSIZE = 1024;

const int NFDBITS = 64;

const int _BITS_PTHREADTYPES_COMMON_H = 1;

const int _THREAD_SHARED_TYPES_H = 1;

const int _BITS_PTHREADTYPES_ARCH_H = 1;

const int __SIZEOF_PTHREAD_MUTEX_T = 40;

const int __SIZEOF_PTHREAD_ATTR_T = 56;

const int __SIZEOF_PTHREAD_RWLOCK_T = 56;

const int __SIZEOF_PTHREAD_BARRIER_T = 32;

const int __SIZEOF_PTHREAD_MUTEXATTR_T = 4;

const int __SIZEOF_PTHREAD_COND_T = 48;

const int __SIZEOF_PTHREAD_CONDATTR_T = 4;

const int __SIZEOF_PTHREAD_RWLOCKATTR_T = 8;

const int __SIZEOF_PTHREAD_BARRIERATTR_T = 4;

const int _THREAD_MUTEX_INTERNAL_H = 1;

const int __PTHREAD_MUTEX_HAVE_PREV = 1;

const int __PTHREAD_RWLOCK_ELISION_EXTRA = 0;

const int __have_pthread_attr_t = 1;

const int _ALLOCA_H = 1;

const int _BITS_SIGNUM_GENERIC_H = 1;

const int SIGINT = 2;

const int SIGILL = 4;

const int SIGABRT = 6;

const int SIGFPE = 8;

const int SIGSEGV = 11;

const int SIGTERM = 15;

const int SIGHUP = 1;

const int SIGQUIT = 3;

const int SIGTRAP = 5;

const int SIGKILL = 9;

const int SIGPIPE = 13;

const int SIGALRM = 14;

const int SIGIO = 29;

const int SIGIOT = 6;

const int SIGCLD = 17;

const int _BITS_SIGNUM_ARCH_H = 1;

const int SIGSTKFLT = 16;

const int SIGPWR = 30;

const int SIGBUS = 7;

const int SIGSYS = 31;

const int SIGURG = 23;

const int SIGSTOP = 19;

const int SIGTSTP = 20;

const int SIGCONT = 18;

const int SIGCHLD = 17;

const int SIGTTIN = 21;

const int SIGTTOU = 22;

const int SIGPOLL = 29;

const int SIGXFSZ = 25;

const int SIGXCPU = 24;

const int SIGVTALRM = 26;

const int SIGPROF = 27;

const int SIGUSR1 = 10;

const int SIGUSR2 = 12;

const int SIGWINCH = 28;

const int __SIGRTMIN = 32;

const int __SIGRTMAX = 64;

const int _NSIG = 65;

const int __sig_atomic_t_defined = 1;

const int __siginfo_t_defined = 1;

const int __SI_MAX_SIZE = 128;

const int __SI_PAD_SIZE = 28;

const int _BITS_SIGINFO_ARCH_H = 1;

const int __SI_ERRNO_THEN_CODE = 1;

const int __SI_HAVE_SIGSYS = 1;

const int _BITS_SIGINFO_CONSTS_H = 1;

const int __SI_ASYNCIO_AFTER_SIGIO = 1;

const int SI_ASYNCNL = -60;

const int SI_DETHREAD = -7;

const int SI_TKILL = -6;

const int SI_SIGIO = -5;

const int SI_ASYNCIO = -4;

const int SI_MESGQ = -3;

const int SI_TIMER = -2;

const int SI_QUEUE = -1;

const int SI_USER = 0;

const int SI_KERNEL = 128;

const int ILL_ILLOPC = 1;

const int ILL_ILLOPN = 2;

const int ILL_ILLADR = 3;

const int ILL_ILLTRP = 4;

const int ILL_PRVOPC = 5;

const int ILL_PRVREG = 6;

const int ILL_COPROC = 7;

const int ILL_BADSTK = 8;

const int ILL_BADIADDR = 9;

const int FPE_INTDIV = 1;

const int FPE_INTOVF = 2;

const int FPE_FLTDIV = 3;

const int FPE_FLTOVF = 4;

const int FPE_FLTUND = 5;

const int FPE_FLTRES = 6;

const int FPE_FLTINV = 7;

const int FPE_FLTSUB = 8;

const int FPE_FLTUNK = 14;

const int FPE_CONDTRAP = 15;

const int SEGV_MAPERR = 1;

const int SEGV_ACCERR = 2;

const int SEGV_BNDERR = 3;

const int SEGV_PKUERR = 4;

const int SEGV_ACCADI = 5;

const int SEGV_ADIDERR = 6;

const int SEGV_ADIPERR = 7;

const int SEGV_MTEAERR = 8;

const int SEGV_MTESERR = 9;

const int SEGV_CPERR = 10;

const int BUS_ADRALN = 1;

const int BUS_ADRERR = 2;

const int BUS_OBJERR = 3;

const int BUS_MCEERR_AR = 4;

const int BUS_MCEERR_AO = 5;

const int CLD_EXITED = 1;

const int CLD_KILLED = 2;

const int CLD_DUMPED = 3;

const int CLD_TRAPPED = 4;

const int CLD_STOPPED = 5;

const int CLD_CONTINUED = 6;

const int POLL_IN = 1;

const int POLL_OUT = 2;

const int POLL_MSG = 3;

const int POLL_ERR = 4;

const int POLL_PRI = 5;

const int POLL_HUP = 6;

const int __sigevent_t_defined = 1;

const int __SIGEV_MAX_SIZE = 64;

const int __SIGEV_PAD_SIZE = 12;

const int _BITS_SIGEVENT_CONSTS_H = 1;

const int SIGEV_SIGNAL = 0;

const int SIGEV_NONE = 1;

const int SIGEV_THREAD = 2;

const int SIGEV_THREAD_ID = 4;

const int NSIG = 65;

const int _BITS_SIGACTION_H = 1;

const int SA_NOCLDSTOP = 1;

const int SA_NOCLDWAIT = 2;

const int SA_SIGINFO = 4;

const int SA_ONSTACK = 134217728;

const int SA_RESTART = 268435456;

const int SA_NODEFER = 1073741824;

const int SA_RESETHAND = 2147483648;

const int SA_INTERRUPT = 536870912;

const int SA_NOMASK = 1073741824;

const int SA_ONESHOT = 2147483648;

const int SA_STACK = 134217728;

const int SIG_BLOCK = 0;

const int SIG_UNBLOCK = 1;

const int SIG_SETMASK = 2;

const int _BITS_SIGCONTEXT_H = 1;

const int FP_XSTATE_MAGIC1 = 1179670611;

const int FP_XSTATE_MAGIC2 = 1179670597;

const int FP_XSTATE_MAGIC2_SIZE = 4;

const int __stack_t_defined = 1;

const int _SYS_UCONTEXT_H = 1;

const int __NGREG = 23;

const int NGREG = 23;

const int _BITS_SIGSTACK_H = 1;

const int _BITS_SS_FLAGS_H = 1;

const int SS_ONSTACK = 1;

const int SS_DISABLE = 2;

const int __sigstack_defined = 1;

const int _BITS_SIGTHREAD_H = 1;

const int G_TIME_SPAN_DAY = 86400000000;

const int G_TIME_SPAN_HOUR = 3600000000;

const int G_TIME_SPAN_MINUTE = 60000000;

const int G_TIME_SPAN_SECOND = 1000000;

const int G_TIME_SPAN_MILLISECOND = 1000;

const int G_DATALIST_FLAGS_MASK = 3;

const int G_DATE_BAD_JULIAN = 0;

const int G_DATE_BAD_DAY = 0;

const int G_DATE_BAD_YEAR = 0;

const int _DIRENT_H = 1;

const int _DIRENT_MATCHES_DIRENT64 = 1;

const int DT_UNKNOWN = 0;

const int DT_FIFO = 1;

const int DT_CHR = 2;

const int DT_DIR = 4;

const int DT_BLK = 6;

const int DT_REG = 8;

const int DT_LNK = 10;

const int DT_SOCK = 12;

const int DT_WHT = 14;

const int MAXNAMLEN = 255;

const int G_MEM_ALIGN = 8;

const int G_HOOK_FLAG_USER_SHIFT = 4;

const int G_PRIORITY_HIGH = -100;

const int G_PRIORITY_DEFAULT = 0;

const int G_PRIORITY_HIGH_IDLE = 100;

const int G_PRIORITY_DEFAULT_IDLE = 200;

const int G_PRIORITY_LOW = 300;

const int G_SOURCE_REMOVE = 0;

const int G_SOURCE_CONTINUE = 1;

const int G_UNICODE_COMBINING_MARK = 10;

const int G_UNICHAR_MAX_DECOMPOSITION_LENGTH = 18;

const String G_STR_DELIMITERS = '_-|> <.';

const int G_ASCII_DTOSTR_BUF_SIZE = 39;

const String G_KEY_FILE_DESKTOP_GROUP = 'Desktop Entry';

const String G_KEY_FILE_DESKTOP_KEY_TYPE = 'Type';

const String G_KEY_FILE_DESKTOP_KEY_VERSION = 'Version';

const String G_KEY_FILE_DESKTOP_KEY_NAME = 'Name';

const String G_KEY_FILE_DESKTOP_KEY_GENERIC_NAME = 'GenericName';

const String G_KEY_FILE_DESKTOP_KEY_NO_DISPLAY = 'NoDisplay';

const String G_KEY_FILE_DESKTOP_KEY_COMMENT = 'Comment';

const String G_KEY_FILE_DESKTOP_KEY_ICON = 'Icon';

const String G_KEY_FILE_DESKTOP_KEY_HIDDEN = 'Hidden';

const String G_KEY_FILE_DESKTOP_KEY_ONLY_SHOW_IN = 'OnlyShowIn';

const String G_KEY_FILE_DESKTOP_KEY_NOT_SHOW_IN = 'NotShowIn';

const String G_KEY_FILE_DESKTOP_KEY_TRY_EXEC = 'TryExec';

const String G_KEY_FILE_DESKTOP_KEY_EXEC = 'Exec';

const String G_KEY_FILE_DESKTOP_KEY_PATH = 'Path';

const String G_KEY_FILE_DESKTOP_KEY_TERMINAL = 'Terminal';

const String G_KEY_FILE_DESKTOP_KEY_MIME_TYPE = 'MimeType';

const String G_KEY_FILE_DESKTOP_KEY_CATEGORIES = 'Categories';

const String G_KEY_FILE_DESKTOP_KEY_STARTUP_NOTIFY = 'StartupNotify';

const String G_KEY_FILE_DESKTOP_KEY_STARTUP_WM_CLASS = 'StartupWMClass';

const String G_KEY_FILE_DESKTOP_KEY_URL = 'URL';

const String G_KEY_FILE_DESKTOP_KEY_DBUS_ACTIVATABLE = 'DBusActivatable';

const String G_KEY_FILE_DESKTOP_KEY_ACTIONS = 'Actions';

const String G_KEY_FILE_DESKTOP_TYPE_APPLICATION = 'Application';

const String G_KEY_FILE_DESKTOP_TYPE_LINK = 'Link';

const String G_KEY_FILE_DESKTOP_TYPE_DIRECTORY = 'Directory';

const int G_LOG_LEVEL_USER_SHIFT = 8;

const int G_LOG_FATAL_MASK = 5;

const String G_OPTION_REMAINING = '';

const int G_REF_COUNT_INIT = -1;

const int G_ATOMIC_REF_COUNT_INIT = 1;

const String G_CSET_A_2_Z = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';

const String G_CSET_a_2_z = 'abcdefghijklmnopqrstuvwxyz';

const String G_CSET_DIGITS = '0123456789';

const String G_CSET_LATINC =
    '\xC0\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\xD0\xD1\xD2\xD3\xD4\xD5\xD6\xD8\xD9\xDA\xDB\xDC\xDD\xDE';

const String G_CSET_LATINS =
    '\xDF\xE0\xE1\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\xF0\xF1\xF2\xF3\xF4\xF5\xF6\xF8\xF9\xFA\xFB\xFC\xFD\xFE\xFF';

const int _ERRNO_H = 1;

const int _BITS_ERRNO_H = 1;

const int EPERM = 1;

const int ENOENT = 2;

const int ESRCH = 3;

const int EINTR = 4;

const int EIO = 5;

const int ENXIO = 6;

const int E2BIG = 7;

const int ENOEXEC = 8;

const int EBADF = 9;

const int ECHILD = 10;

const int EAGAIN = 11;

const int ENOMEM = 12;

const int EACCES = 13;

const int EFAULT = 14;

const int ENOTBLK = 15;

const int EBUSY = 16;

const int EEXIST = 17;

const int EXDEV = 18;

const int ENODEV = 19;

const int ENOTDIR = 20;

const int EISDIR = 21;

const int EINVAL = 22;

const int ENFILE = 23;

const int EMFILE = 24;

const int ENOTTY = 25;

const int ETXTBSY = 26;

const int EFBIG = 27;

const int ENOSPC = 28;

const int ESPIPE = 29;

const int EROFS = 30;

const int EMLINK = 31;

const int EPIPE = 32;

const int EDOM = 33;

const int ERANGE = 34;

const int EDEADLK = 35;

const int ENAMETOOLONG = 36;

const int ENOLCK = 37;

const int ENOSYS = 38;

const int ENOTEMPTY = 39;

const int ELOOP = 40;

const int EWOULDBLOCK = 11;

const int ENOMSG = 42;

const int EIDRM = 43;

const int ECHRNG = 44;

const int EL2NSYNC = 45;

const int EL3HLT = 46;

const int EL3RST = 47;

const int ELNRNG = 48;

const int EUNATCH = 49;

const int ENOCSI = 50;

const int EL2HLT = 51;

const int EBADE = 52;

const int EBADR = 53;

const int EXFULL = 54;

const int ENOANO = 55;

const int EBADRQC = 56;

const int EBADSLT = 57;

const int EDEADLOCK = 35;

const int EBFONT = 59;

const int ENOSTR = 60;

const int ENODATA = 61;

const int ETIME = 62;

const int ENOSR = 63;

const int ENONET = 64;

const int ENOPKG = 65;

const int EREMOTE = 66;

const int ENOLINK = 67;

const int EADV = 68;

const int ESRMNT = 69;

const int ECOMM = 70;

const int EPROTO = 71;

const int EMULTIHOP = 72;

const int EDOTDOT = 73;

const int EBADMSG = 74;

const int EOVERFLOW = 75;

const int ENOTUNIQ = 76;

const int EBADFD = 77;

const int EREMCHG = 78;

const int ELIBACC = 79;

const int ELIBBAD = 80;

const int ELIBSCN = 81;

const int ELIBMAX = 82;

const int ELIBEXEC = 83;

const int EILSEQ = 84;

const int ERESTART = 85;

const int ESTRPIPE = 86;

const int EUSERS = 87;

const int ENOTSOCK = 88;

const int EDESTADDRREQ = 89;

const int EMSGSIZE = 90;

const int EPROTOTYPE = 91;

const int ENOPROTOOPT = 92;

const int EPROTONOSUPPORT = 93;

const int ESOCKTNOSUPPORT = 94;

const int EOPNOTSUPP = 95;

const int EPFNOSUPPORT = 96;

const int EAFNOSUPPORT = 97;

const int EADDRINUSE = 98;

const int EADDRNOTAVAIL = 99;

const int ENETDOWN = 100;

const int ENETUNREACH = 101;

const int ENETRESET = 102;

const int ECONNABORTED = 103;

const int ECONNRESET = 104;

const int ENOBUFS = 105;

const int EISCONN = 106;

const int ENOTCONN = 107;

const int ESHUTDOWN = 108;

const int ETOOMANYREFS = 109;

const int ETIMEDOUT = 110;

const int ECONNREFUSED = 111;

const int EHOSTDOWN = 112;

const int EHOSTUNREACH = 113;

const int EALREADY = 114;

const int EINPROGRESS = 115;

const int ESTALE = 116;

const int EUCLEAN = 117;

const int ENOTNAM = 118;

const int ENAVAIL = 119;

const int EISNAM = 120;

const int EREMOTEIO = 121;

const int EDQUOT = 122;

const int ENOMEDIUM = 123;

const int EMEDIUMTYPE = 124;

const int ECANCELED = 125;

const int ENOKEY = 126;

const int EKEYEXPIRED = 127;

const int EKEYREVOKED = 128;

const int EKEYREJECTED = 129;

const int EOWNERDEAD = 130;

const int ENOTRECOVERABLE = 131;

const int ERFKILL = 132;

const int EHWPOISON = 133;

const int ENOTSUP = 95;

const String G_TEST_OPTION_ISOLATE_DIRS = 'isolate_dirs';

const int G_USEC_PER_SEC = 1000000;

const String G_URI_RESERVED_CHARS_GENERIC_DELIMITERS = ':/?#[]@';

const String G_URI_RESERVED_CHARS_SUBCOMPONENT_DELIMITERS = '!\$&\'()*+,;=';

const String G_URI_RESERVED_CHARS_ALLOWED_IN_PATH_ELEMENT = '!\$&\'()*+,;=:@';

const String G_URI_RESERVED_CHARS_ALLOWED_IN_PATH = '!\$&\'()*+,;=:@/';

const String G_URI_RESERVED_CHARS_ALLOWED_IN_USERINFO = '!\$&\'()*+,;=:';

const int G_ALLOC_ONLY = 1;

const int G_ALLOC_AND_FREE = 2;

const int G_ALLOCATOR_LIST = 1;

const int G_ALLOCATOR_SLIST = 2;

const int G_ALLOCATOR_NODE = 3;

const int _PTHREAD_H = 1;

const int _SCHED_H = 1;

const int _BITS_SCHED_H = 1;

const int SCHED_OTHER = 0;

const int SCHED_FIFO = 1;

const int SCHED_RR = 2;

const int _BITS_TYPES_STRUCT_SCHED_PARAM = 1;

const int _BITS_CPU_SET_H = 1;

const int __CPU_SETSIZE = 1024;

const int __NCPUBITS = 64;

const int _BITS_SETJMP_H = 1;

const int __jmp_buf_tag_defined = 1;

const int PTHREAD_CREATE_JOINABLE = 0;

const int PTHREAD_CREATE_DETACHED = 1;

const int PTHREAD_INHERIT_SCHED = 0;

const int PTHREAD_EXPLICIT_SCHED = 1;

const int PTHREAD_SCOPE_SYSTEM = 0;

const int PTHREAD_SCOPE_PROCESS = 1;

const int PTHREAD_PROCESS_PRIVATE = 0;

const int PTHREAD_PROCESS_SHARED = 1;

const int PTHREAD_CANCEL_ENABLE = 0;

const int PTHREAD_CANCEL_DISABLE = 1;

const int PTHREAD_CANCEL_DEFERRED = 0;

const int PTHREAD_CANCEL_ASYNCHRONOUS = 1;

const int PTHREAD_ONCE_INIT = 0;

const int PTHREAD_BARRIER_SERIAL_THREAD = -1;

const int G_TYPE_FUNDAMENTAL_SHIFT = 2;

const int G_TYPE_FUNDAMENTAL_MAX = 1020;

const int G_TYPE_INVALID = 0;

const int G_TYPE_NONE = 4;

const int G_TYPE_INTERFACE = 8;

const int G_TYPE_CHAR = 12;

const int G_TYPE_UCHAR = 16;

const int G_TYPE_BOOLEAN = 20;

const int G_TYPE_INT = 24;

const int G_TYPE_UINT = 28;

const int G_TYPE_LONG = 32;

const int G_TYPE_ULONG = 36;

const int G_TYPE_INT64 = 40;

const int G_TYPE_UINT64 = 44;

const int G_TYPE_ENUM = 48;

const int G_TYPE_FLAGS = 52;

const int G_TYPE_FLOAT = 56;

const int G_TYPE_DOUBLE = 60;

const int G_TYPE_STRING = 64;

const int G_TYPE_POINTER = 68;

const int G_TYPE_BOXED = 72;

const int G_TYPE_PARAM = 76;

const int G_TYPE_OBJECT = 80;

const int G_TYPE_VARIANT = 84;

const int G_TYPE_RESERVED_GLIB_FIRST = 22;

const int G_TYPE_RESERVED_GLIB_LAST = 31;

const int G_TYPE_RESERVED_BSE_FIRST = 32;

const int G_TYPE_RESERVED_BSE_LAST = 48;

const int G_TYPE_RESERVED_USER_FIRST = 49;

const int G_TYPE_FLAG_RESERVED_ID_BIT = 1;

const int G_VALUE_NOCOPY_CONTENTS = 134217728;

const int G_VALUE_INTERNED_STRING = 268435456;

const int G_PARAM_STATIC_STRINGS = 224;

const int G_PARAM_MASK = 255;

const int G_PARAM_USER_SHIFT = 8;

const int G_SIGNAL_FLAGS_MASK = 511;

const int G_SIGNAL_MATCH_MASK = 63;

const int G_SIGNAL_TYPE_STATIC_SCOPE = 1;

const int GST_PADDING = 4;

const int GST_PADDING_LARGE = 20;

const int GST_DISABLE_CAST_CHECKS = 0;

const int GST_DISABLE_GLIB_ASSERTS = 0;

const int GST_DISABLE_GLIB_CHECKS = 0;

const int GST_HAVE_UNALIGNED_ACCESS = 1;

const int GST_VERSION_MAJOR = 1;

const int GST_VERSION_MINOR = 24;

const int GST_VERSION_MICRO = 10;

const int GST_VERSION_NANO = 0;

const int GST_TYPE_CLOCK_TIME = 44;

const int GST_CLOCK_TIME_NONE = -1;

const int GST_CLOCK_STIME_NONE = -9223372036854775808;

const int GST_SECOND = 1000000000;

const int GST_MSECOND = 1000000;

const int GST_USECOND = 1000;

const int GST_NSECOND = 1;

const String GST_TIME_FORMAT = 'u:%02u:%02u.%09u';

const String GST_STIME_FORMAT = 'c%u:%02u:%02u.%09u';

const int GST_LOCK_FLAG_READWRITE = 3;

const int GST_MAP_READWRITE = 3;

const String GST_ALLOCATOR_SYSMEM = 'SystemMemory';

const String GST_CAPS_FEATURE_MEMORY_SYSTEM_MEMORY = 'memory:SystemMemory';

const String GST_META_TAG_MEMORY_STR = 'memory';

const String GST_META_TAG_MEMORY_REFERENCE_STR = 'memory-reference';

const int GST_BUFFER_OFFSET_NONE = -1;

const int GST_BUFFER_COPY_METADATA = 7;

const int GST_BUFFER_COPY_ALL = 15;

const int GST_EVENT_TYPE_BOTH = 3;

const int GST_EVENT_NUM_SHIFT = 8;

const int GST_FORMAT_PERCENT_MAX = 1000000;

const int GST_FORMAT_PERCENT_SCALE = 10000;

const int GST_SEGMENT_INSTANT_FLAGS = 912;

const String GST_TAG_TITLE = 'title';

const String GST_TAG_TITLE_SORTNAME = 'title-sortname';

const String GST_TAG_ARTIST = 'artist';

const String GST_TAG_ARTIST_SORTNAME = 'artist-sortname';

const String GST_TAG_ALBUM = 'album';

const String GST_TAG_ALBUM_SORTNAME = 'album-sortname';

const String GST_TAG_ALBUM_ARTIST = 'album-artist';

const String GST_TAG_ALBUM_ARTIST_SORTNAME = 'album-artist-sortname';

const String GST_TAG_COMPOSER = 'composer';

const String GST_TAG_CONDUCTOR = 'conductor';

const String GST_TAG_DATE = 'date';

const String GST_TAG_DATE_TIME = 'datetime';

const String GST_TAG_GENRE = 'genre';

const String GST_TAG_COMMENT = 'comment';

const String GST_TAG_EXTENDED_COMMENT = 'extended-comment';

const String GST_TAG_TRACK_NUMBER = 'track-number';

const String GST_TAG_TRACK_COUNT = 'track-count';

const String GST_TAG_ALBUM_VOLUME_NUMBER = 'album-disc-number';

const String GST_TAG_ALBUM_VOLUME_COUNT = 'album-disc-count';

const String GST_TAG_LOCATION = 'location';

const String GST_TAG_HOMEPAGE = 'homepage';

const String GST_TAG_DESCRIPTION = 'description';

const String GST_TAG_VERSION = 'version';

const String GST_TAG_ISRC = 'isrc';

const String GST_TAG_ORGANIZATION = 'organization';

const String GST_TAG_COPYRIGHT = 'copyright';

const String GST_TAG_COPYRIGHT_URI = 'copyright-uri';

const String GST_TAG_ENCODED_BY = 'encoded-by';

const String GST_TAG_CONTACT = 'contact';

const String GST_TAG_LICENSE = 'license';

const String GST_TAG_LICENSE_URI = 'license-uri';

const String GST_TAG_PERFORMER = 'performer';

const String GST_TAG_DURATION = 'duration';

const String GST_TAG_CODEC = 'codec';

const String GST_TAG_VIDEO_CODEC = 'video-codec';

const String GST_TAG_AUDIO_CODEC = 'audio-codec';

const String GST_TAG_SUBTITLE_CODEC = 'subtitle-codec';

const String GST_TAG_CONTAINER_FORMAT = 'container-format';

const String GST_TAG_BITRATE = 'bitrate';

const String GST_TAG_NOMINAL_BITRATE = 'nominal-bitrate';

const String GST_TAG_MINIMUM_BITRATE = 'minimum-bitrate';

const String GST_TAG_MAXIMUM_BITRATE = 'maximum-bitrate';

const String GST_TAG_SERIAL = 'serial';

const String GST_TAG_ENCODER = 'encoder';

const String GST_TAG_ENCODER_VERSION = 'encoder-version';

const String GST_TAG_TRACK_GAIN = 'replaygain-track-gain';

const String GST_TAG_TRACK_PEAK = 'replaygain-track-peak';

const String GST_TAG_ALBUM_GAIN = 'replaygain-album-gain';

const String GST_TAG_ALBUM_PEAK = 'replaygain-album-peak';

const String GST_TAG_REFERENCE_LEVEL = 'replaygain-reference-level';

const String GST_TAG_LANGUAGE_CODE = 'language-code';

const String GST_TAG_LANGUAGE_NAME = 'language-name';

const String GST_TAG_IMAGE = 'image';

const String GST_TAG_PREVIEW_IMAGE = 'preview-image';

const String GST_TAG_ATTACHMENT = 'attachment';

const String GST_TAG_BEATS_PER_MINUTE = 'beats-per-minute';

const String GST_TAG_KEYWORDS = 'keywords';

const String GST_TAG_GEO_LOCATION_NAME = 'geo-location-name';

const String GST_TAG_GEO_LOCATION_LATITUDE = 'geo-location-latitude';

const String GST_TAG_GEO_LOCATION_LONGITUDE = 'geo-location-longitude';

const String GST_TAG_GEO_LOCATION_ELEVATION = 'geo-location-elevation';

const String GST_TAG_GEO_LOCATION_COUNTRY = 'geo-location-country';

const String GST_TAG_GEO_LOCATION_CITY = 'geo-location-city';

const String GST_TAG_GEO_LOCATION_SUBLOCATION = 'geo-location-sublocation';

const String GST_TAG_GEO_LOCATION_HORIZONTAL_ERROR =
    'geo-location-horizontal-error';

const String GST_TAG_GEO_LOCATION_MOVEMENT_SPEED =
    'geo-location-movement-speed';

const String GST_TAG_GEO_LOCATION_MOVEMENT_DIRECTION =
    'geo-location-movement-direction';

const String GST_TAG_GEO_LOCATION_CAPTURE_DIRECTION =
    'geo-location-capture-direction';

const String GST_TAG_SHOW_NAME = 'show-name';

const String GST_TAG_SHOW_SORTNAME = 'show-sortname';

const String GST_TAG_SHOW_EPISODE_NUMBER = 'show-episode-number';

const String GST_TAG_SHOW_SEASON_NUMBER = 'show-season-number';

const String GST_TAG_LYRICS = 'lyrics';

const String GST_TAG_COMPOSER_SORTNAME = 'composer-sortname';

const String GST_TAG_GROUPING = 'grouping';

const String GST_TAG_USER_RATING = 'user-rating';

const String GST_TAG_DEVICE_MANUFACTURER = 'device-manufacturer';

const String GST_TAG_DEVICE_MODEL = 'device-model';

const String GST_TAG_APPLICATION_NAME = 'application-name';

const String GST_TAG_APPLICATION_DATA = 'application-data';

const String GST_TAG_IMAGE_ORIENTATION = 'image-orientation';

const String GST_TAG_PUBLISHER = 'publisher';

const String GST_TAG_INTERPRETED_BY = 'interpreted-by';

const String GST_TAG_MIDI_BASE_NOTE = 'midi-base-note';

const String GST_TAG_PRIVATE_DATA = 'private-data';

const String GST_TAG_CONTAINER_SPECIFIC_TRACK_ID =
    'container-specific-track-id';

const int GST_QUERY_TYPE_BOTH = 3;

const int GST_QUERY_NUM_SHIFT = 8;

const int GST_TOC_REPEAT_COUNT_INFINITE = -1;

const int GST_CAN_INLINE = 1;

const int __GST_PACKAGE_RELEASE_DATETIME = 0;

const String GST_LICENSE_UNKNOWN = 'unknown';

const int GST_URI_NO_PORT = 0;

const int GST_ELEMENT_FACTORY_TYPE_DECODER = 1;

const int GST_ELEMENT_FACTORY_TYPE_ENCODER = 2;

const int GST_ELEMENT_FACTORY_TYPE_SINK = 4;

const int GST_ELEMENT_FACTORY_TYPE_SRC = 8;

const int GST_ELEMENT_FACTORY_TYPE_MUXER = 16;

const int GST_ELEMENT_FACTORY_TYPE_DEMUXER = 32;

const int GST_ELEMENT_FACTORY_TYPE_PARSER = 64;

const int GST_ELEMENT_FACTORY_TYPE_PAYLOADER = 128;

const int GST_ELEMENT_FACTORY_TYPE_DEPAYLOADER = 256;

const int GST_ELEMENT_FACTORY_TYPE_FORMATTER = 512;

const int GST_ELEMENT_FACTORY_TYPE_DECRYPTOR = 1024;

const int GST_ELEMENT_FACTORY_TYPE_ENCRYPTOR = 2048;

const int GST_ELEMENT_FACTORY_TYPE_HARDWARE = 4096;

const int GST_ELEMENT_FACTORY_TYPE_TIMESTAMPER = 8192;

const int GST_ELEMENT_FACTORY_TYPE_MAX_ELEMENTS = 281474976710656;

const int GST_ELEMENT_FACTORY_TYPE_MEDIA_VIDEO = 562949953421312;

const int GST_ELEMENT_FACTORY_TYPE_MEDIA_AUDIO = 1125899906842624;

const int GST_ELEMENT_FACTORY_TYPE_MEDIA_IMAGE = 2251799813685248;

const int GST_ELEMENT_FACTORY_TYPE_MEDIA_SUBTITLE = 4503599627370496;

const int GST_ELEMENT_FACTORY_TYPE_MEDIA_METADATA = 9007199254740992;

const int GST_ELEMENT_FACTORY_TYPE_ANY = 562949953421311;

const int GST_ELEMENT_FACTORY_TYPE_MEDIA_ANY = -281474976710656;

const int GST_ELEMENT_FACTORY_TYPE_VIDEO_ENCODER = 2814749767106562;

const int GST_ELEMENT_FACTORY_TYPE_AUDIO_ENCODER = 1125899906842626;

const int GST_ELEMENT_FACTORY_TYPE_AUDIOVIDEO_SINKS = 3940649673949188;

const int GST_ELEMENT_FACTORY_TYPE_DECODABLE = 1377;

const String GST_ELEMENT_FACTORY_KLASS_DECODER = 'Decoder';

const String GST_ELEMENT_FACTORY_KLASS_ENCODER = 'Encoder';

const String GST_ELEMENT_FACTORY_KLASS_SINK = 'Sink';

const String GST_ELEMENT_FACTORY_KLASS_SRC = 'Source';

const String GST_ELEMENT_FACTORY_KLASS_MUXER = 'Muxer';

const String GST_ELEMENT_FACTORY_KLASS_DEMUXER = 'Demuxer';

const String GST_ELEMENT_FACTORY_KLASS_PARSER = 'Parser';

const String GST_ELEMENT_FACTORY_KLASS_PAYLOADER = 'Payloader';

const String GST_ELEMENT_FACTORY_KLASS_DEPAYLOADER = 'Depayloader';

const String GST_ELEMENT_FACTORY_KLASS_FORMATTER = 'Formatter';

const String GST_ELEMENT_FACTORY_KLASS_DECRYPTOR = 'Decryptor';

const String GST_ELEMENT_FACTORY_KLASS_ENCRYPTOR = 'Encryptor';

const String GST_ELEMENT_FACTORY_KLASS_MEDIA_VIDEO = 'Video';

const String GST_ELEMENT_FACTORY_KLASS_MEDIA_AUDIO = 'Audio';

const String GST_ELEMENT_FACTORY_KLASS_MEDIA_IMAGE = 'Image';

const String GST_ELEMENT_FACTORY_KLASS_MEDIA_SUBTITLE = 'Subtitle';

const String GST_ELEMENT_FACTORY_KLASS_MEDIA_METADATA = 'Metadata';

const String GST_ELEMENT_FACTORY_KLASS_HARDWARE = 'Hardware';

const String GST_ELEMENT_METADATA_LONGNAME = 'long-name';

const String GST_ELEMENT_METADATA_KLASS = 'klass';

const String GST_ELEMENT_METADATA_DESCRIPTION = 'description';

const String GST_ELEMENT_METADATA_AUTHOR = 'author';

const String GST_ELEMENT_METADATA_DOC_URI = 'doc-uri';

const String GST_ELEMENT_METADATA_ICON_NAME = 'icon-name';

const int GST_LEVEL_DEFAULT = 0;

const int GST_LEVEL_MAX = 10;

const int GST_DEBUG_FG_MASK = 15;

const int GST_DEBUG_BG_MASK = 240;

const int GST_DEBUG_FORMAT_MASK = 65280;

const String GST_PTR_FORMAT = 'p\x07A';

const String GST_SEGMENT_FORMAT = 'p\x07B';

const String GST_TIMEP_FORMAT = 'p\x07T';

const String GST_STIMEP_FORMAT = 'p\x07S';

const String GST_FOURCC_FORMAT = 'c%c%c%c';

const int GST_FLAG_SET_MASK_EXACT = 4294967295;

const int GST_VALUE_LESS_THAN = -1;

const int GST_VALUE_EQUAL = 0;

const int GST_VALUE_GREATER_THAN = 1;

const int GST_VALUE_UNORDERED = 2;

const int GST_PARAM_CONTROLLABLE = 512;

const int GST_PARAM_MUTABLE_READY = 1024;

const int GST_PARAM_MUTABLE_PAUSED = 2048;

const int GST_PARAM_MUTABLE_PLAYING = 4096;

const int GST_PARAM_DOC_SHOW_DEFAULT = 8192;

const int GST_PARAM_CONDITIONALLY_AVAILABLE = 16384;

const int GST_PARAM_USER_SHIFT = 65536;

const String GST_PROTECTION_SYSTEM_ID_CAPS_FIELD = 'protection-system';

const String GST_PROTECTION_UNSPECIFIED_SYSTEM_ID = 'unspecified-system-id';

const int GST_SEQNUM_INVALID = 0;

const int GST_GROUP_ID_INVALID = 0;

const int GST_MESSAGE_DURATION = 262144;

const int GST_BASE_SINK_FLOW_DROPPED = 100;
